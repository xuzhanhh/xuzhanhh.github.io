{
  "nodes": {
    "SitePage /dev-404-page/": {
      "path": "/dev-404-page/",
      "id": "SitePage /dev-404-page/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "f91d29e10ba680b413138cf9ed86e655",
        "owner": "internal-data-bridge"
      }
    },
    "d48d1c52-fe48-53cb-8f08-aa4b47dde5a5": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/dev-404-page",
      "id": "d48d1c52-fe48-53cb-8f08-aa4b47dde5a5",
      "name": "dev-404-page",
      "version": "1.0.0",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "createPagesStatefully"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/dev-404-page",
      "packageJson": {
        "name": "dev-404-page",
        "description": "Internal plugin to add a 404 page in development with helpful information",
        "version": "1.0.0",
        "main": "index.js",
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [],
        "devDependencies": [],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "c5dc32e8672ffa3711c9f14a985665c5",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "1fc32581-893a-55e8-8927-bcd667e2b700": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/load-babel-config",
      "id": "1fc32581-893a-55e8-8927-bcd667e2b700",
      "name": "load-babel-config",
      "version": "1.0.0",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onPreBootstrap"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/load-babel-config",
      "packageJson": {
        "name": "load-babel-config",
        "description": "Internal plugin that handles loading Babel configs",
        "version": "1.0.0",
        "main": "index.js",
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [],
        "devDependencies": [],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "6f5dd718a65e911d99ba9bfc681527ee",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "a5079d69-ba80-53dc-82f9-0f440bd5448c": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/internal-data-bridge",
      "id": "a5079d69-ba80-53dc-82f9-0f440bd5448c",
      "name": "internal-data-bridge",
      "version": "1.0.0",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "sourceNodes",
        "onCreatePage"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/internal-data-bridge",
      "packageJson": {
        "name": "internal-data-bridge",
        "description": "An internal Gatsby plugin which creates data nodes from internal data",
        "version": "1.0.0",
        "main": "index.js",
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [],
        "devDependencies": [],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "ddecd3e2945140d003bb16552a2a66da",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "f795702c-a3b8-5a88-88ee-5d06019d44fa": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/prod-404",
      "id": "f795702c-a3b8-5a88-88ee-5d06019d44fa",
      "name": "prod-404",
      "version": "1.0.0",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onCreatePage"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/prod-404",
      "packageJson": {
        "name": "prod-404",
        "description": "Internal plugin to detect various flavors of 404 pages and ensure there's a 404.html path created as well to ensure compatability with static hosts",
        "version": "1.0.0",
        "main": "index.js",
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [],
        "devDependencies": [],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "a49125cb2da03cd5866ffbf7f0eb3bb8",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "84dad27f-1d44-51fc-ac56-4db2e5222995": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/query-runner",
      "id": "84dad27f-1d44-51fc-ac56-4db2e5222995",
      "name": "query-runner",
      "version": "1.0.0",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onCreatePage"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/query-runner",
      "packageJson": {
        "name": "query-runner",
        "description": "Internal plugin for running queries",
        "version": "1.0.0",
        "main": "index.js",
        "author": "",
        "license": "MIT",
        "dependencies": [],
        "devDependencies": [],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "340aacadac9e7d5d027402666b8ddc7a",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "6f4b2fa9-66b5-5205-a03f-140005a2cfe5": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/webpack-theme-component-shadowing",
      "id": "6f4b2fa9-66b5-5205-a03f-140005a2cfe5",
      "name": "webpack-theme-component-shadowing",
      "version": "1.0.0",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onCreateWebpackConfig"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby/dist/internal-plugins/webpack-theme-component-shadowing",
      "packageJson": {
        "name": "webpack-theme-component-shadowing",
        "description": "An internal Gatsby plugin which handles configuring webpack to ensure theme components fall back from the user's site to theme modules.",
        "version": "1.0.0",
        "main": "index.js",
        "author": "Chris Biscardi <chris@christopherbiscardi.com>",
        "license": "MIT",
        "dependencies": [],
        "devDependencies": [],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "1f94bf8c57ab5c9d0493211894e07fab",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "6b7473d7-11d5-5975-a1ef-2c4465ca30e9": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-source-filesystem",
      "id": "6b7473d7-11d5-5975-a1ef-2c4465ca30e9",
      "name": "gatsby-source-filesystem",
      "version": "2.0.10",
      "pluginOptions": {
        "plugins": [],
        "path": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
        "name": "pages"
      },
      "nodeAPIs": [
        "sourceNodes",
        "setFieldsOnGraphQLNodeType"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-source-filesystem",
      "packageJson": {
        "name": "gatsby-source-filesystem",
        "description": "Gatsby plugin which parses files within a directory for further parsing by other plugins",
        "version": "2.0.10",
        "keywords": [
          "gatsby",
          "gatsby-plugin"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "better-queue",
            "version": "^3.8.7"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "chokidar",
            "version": "^1.7.0"
          },
          {
            "name": "file-type",
            "version": "^10.2.0"
          },
          {
            "name": "fs-extra",
            "version": "^5.0.0"
          },
          {
            "name": "got",
            "version": "^7.1.0"
          },
          {
            "name": "md5-file",
            "version": "^3.1.1"
          },
          {
            "name": "mime",
            "version": "^2.2.0"
          },
          {
            "name": "pretty-bytes",
            "version": "^4.0.2"
          },
          {
            "name": "read-chunk",
            "version": "^3.0.0"
          },
          {
            "name": "slash",
            "version": "^1.0.0"
          },
          {
            "name": "valid-url",
            "version": "^1.0.9"
          },
          {
            "name": "xstate",
            "version": "^3.1.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "73ebc1bfeac83572ae4d773ef4ccf55b",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "1410f0a6-4bed-597e-bbd8-cfa10306010a": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-transformer-remark",
      "id": "1410f0a6-4bed-597e-bbd8-cfa10306010a",
      "name": "gatsby-transformer-remark",
      "version": "2.1.15",
      "pluginOptions": {
        "plugins": [
          {
            "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-images",
            "id": "4a359a36-fef3-5c49-a0f9-45c24a5fd434",
            "name": "gatsby-remark-images",
            "version": "2.0.6",
            "pluginOptions": {
              "plugins": [],
              "maxWidth": 590,
              "wrapperStyle": "",
              "backgroundColor": "white",
              "linkImagesToOriginal": true,
              "showCaptions": false,
              "pathPrefix": "",
              "withWebp": false
            },
            "nodeAPIs": [],
            "browserAPIs": [],
            "ssrAPIs": [],
            "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-images"
          },
          {
            "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-responsive-iframe",
            "id": "1a3d9dbf-c3c7-50dc-9f59-97f0cf8bb163",
            "name": "gatsby-remark-responsive-iframe",
            "version": "2.0.7",
            "pluginOptions": {
              "plugins": [],
              "wrapperStyle": "margin-bottom: 1.0725rem"
            },
            "nodeAPIs": [],
            "browserAPIs": [],
            "ssrAPIs": [],
            "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-responsive-iframe"
          },
          {
            "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-prismjs",
            "id": "83cfc03c-b808-589d-aa21-bdd6ebeda192",
            "name": "gatsby-remark-prismjs",
            "version": "3.1.2",
            "pluginOptions": {
              "plugins": [],
              "inlineCodeMarker": "÷"
            },
            "nodeAPIs": [],
            "browserAPIs": [],
            "ssrAPIs": [],
            "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-prismjs"
          },
          {
            "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-copy-linked-files",
            "id": "80533a5b-ad2d-50ff-af51-726674869458",
            "name": "gatsby-remark-copy-linked-files",
            "version": "2.0.7",
            "pluginOptions": {
              "plugins": [],
              "ignoreFileExtensions": [
                "png",
                "jpg",
                "jpeg",
                "bmp",
                "tiff"
              ]
            },
            "nodeAPIs": [],
            "browserAPIs": [],
            "ssrAPIs": [],
            "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-copy-linked-files"
          },
          {
            "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-smartypants",
            "id": "90305615-131b-5991-a708-2c2d1c43d946",
            "name": "gatsby-remark-smartypants",
            "version": "2.0.7",
            "pluginOptions": {
              "plugins": []
            },
            "nodeAPIs": [],
            "browserAPIs": [],
            "ssrAPIs": [],
            "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-smartypants"
          }
        ]
      },
      "nodeAPIs": [
        "onCreateNode",
        "setFieldsOnGraphQLNodeType"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-transformer-remark",
      "packageJson": {
        "name": "gatsby-transformer-remark",
        "description": "Gatsby transformer plugin for Markdown using the Remark library and ecosystem",
        "version": "2.1.15",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "markdown",
          "remark"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "gray-matter",
            "version": "^4.0.0"
          },
          {
            "name": "hast-util-raw",
            "version": "^4.0.0"
          },
          {
            "name": "hast-util-to-html",
            "version": "^4.0.0"
          },
          {
            "name": "lodash",
            "version": "^4.17.10"
          },
          {
            "name": "mdast-util-to-hast",
            "version": "^3.0.0"
          },
          {
            "name": "mdast-util-toc",
            "version": "^2.0.1"
          },
          {
            "name": "remark",
            "version": "^9.0.0"
          },
          {
            "name": "remark-parse",
            "version": "^5.0.0"
          },
          {
            "name": "remark-retext",
            "version": "^3.1.0"
          },
          {
            "name": "remark-stringify",
            "version": "^5.0.0"
          },
          {
            "name": "retext-english",
            "version": "^3.0.0"
          },
          {
            "name": "sanitize-html",
            "version": "^1.18.2"
          },
          {
            "name": "underscore.string",
            "version": "^3.3.4"
          },
          {
            "name": "unified",
            "version": "^6.1.5"
          },
          {
            "name": "unist-util-remove-position",
            "version": "^1.1.2"
          },
          {
            "name": "unist-util-select",
            "version": "^1.5.0"
          },
          {
            "name": "unist-util-visit",
            "version": "^1.3.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": "^2.0.33"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "1562254c7f8122eea54b228502c1ade2",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "4a359a36-fef3-5c49-a0f9-45c24a5fd434": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-images",
      "id": "4a359a36-fef3-5c49-a0f9-45c24a5fd434",
      "name": "gatsby-remark-images",
      "version": "2.0.6",
      "pluginOptions": {
        "plugins": [],
        "maxWidth": 590,
        "wrapperStyle": "",
        "backgroundColor": "white",
        "linkImagesToOriginal": true,
        "showCaptions": false,
        "pathPrefix": "",
        "withWebp": false
      },
      "nodeAPIs": [],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-images",
      "packageJson": {
        "name": "gatsby-remark-images",
        "description": "Processes images in markdown so they can be used in the production build.",
        "version": "2.0.6",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "image",
          "markdown",
          "remark",
          "responsive images"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "cheerio",
            "version": "^1.0.0-rc.2"
          },
          {
            "name": "is-relative-url",
            "version": "^2.0.0"
          },
          {
            "name": "lodash",
            "version": "^4.17.10"
          },
          {
            "name": "slash",
            "version": "^1.0.0"
          },
          {
            "name": "unist-util-select",
            "version": "^1.5.0"
          },
          {
            "name": "unist-util-visit-parents",
            "version": "^2.0.1"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.2"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          },
          {
            "name": "gatsby-plugin-sharp",
            "version": "^2.0.0-beta.5"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "4054764a06439c6db1a8585efb6bbe8f",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "1a3d9dbf-c3c7-50dc-9f59-97f0cf8bb163": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-responsive-iframe",
      "id": "1a3d9dbf-c3c7-50dc-9f59-97f0cf8bb163",
      "name": "gatsby-remark-responsive-iframe",
      "version": "2.0.7",
      "pluginOptions": {
        "plugins": [],
        "wrapperStyle": "margin-bottom: 1.0725rem"
      },
      "nodeAPIs": [],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-responsive-iframe",
      "packageJson": {
        "name": "gatsby-remark-responsive-iframe",
        "description": "Make iframes in Markdown processed by Remark responsive",
        "version": "2.0.7",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "remark"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "cheerio",
            "version": "^1.0.0-rc.2"
          },
          {
            "name": "lodash",
            "version": "^4.17.10"
          },
          {
            "name": "unist-util-visit",
            "version": "^1.3.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          },
          {
            "name": "remark",
            "version": "^9.0.0"
          },
          {
            "name": "unist-util-find",
            "version": "^1.0.1"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "0750beea1beab9512d3282360ef26c07",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "83cfc03c-b808-589d-aa21-bdd6ebeda192": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-prismjs",
      "id": "83cfc03c-b808-589d-aa21-bdd6ebeda192",
      "name": "gatsby-remark-prismjs",
      "version": "3.1.2",
      "pluginOptions": {
        "plugins": [],
        "inlineCodeMarker": "÷"
      },
      "nodeAPIs": [],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-prismjs",
      "packageJson": {
        "name": "gatsby-remark-prismjs",
        "description": "Adds syntax highlighting to code blocks at build time using PrismJS",
        "version": "3.1.2",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "prismjs",
          "remark"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "parse-numeric-range",
            "version": "^0.0.2"
          },
          {
            "name": "unist-util-visit",
            "version": "^1.3.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          },
          {
            "name": "prismjs",
            "version": "^1.15.0"
          },
          {
            "name": "remark",
            "version": "^9.0.0"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          },
          {
            "name": "prismjs",
            "version": "^1.15.0"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "7f7d80054d514440bf7377fbed630300",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "80533a5b-ad2d-50ff-af51-726674869458": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-copy-linked-files",
      "id": "80533a5b-ad2d-50ff-af51-726674869458",
      "name": "gatsby-remark-copy-linked-files",
      "version": "2.0.7",
      "pluginOptions": {
        "plugins": [],
        "ignoreFileExtensions": [
          "png",
          "jpg",
          "jpeg",
          "bmp",
          "tiff"
        ]
      },
      "nodeAPIs": [],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-copy-linked-files",
      "packageJson": {
        "name": "gatsby-remark-copy-linked-files",
        "description": "Find files which are linked to from markdown and copy them to the public directory",
        "version": "2.0.7",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "prismjs",
          "remark"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "cheerio",
            "version": "^1.0.0-rc.2"
          },
          {
            "name": "fs-extra",
            "version": "^4.0.1"
          },
          {
            "name": "is-relative-url",
            "version": "^2.0.0"
          },
          {
            "name": "lodash",
            "version": "^4.17.10"
          },
          {
            "name": "path-is-inside",
            "version": "^1.0.2"
          },
          {
            "name": "probe-image-size",
            "version": "^4.0.0"
          },
          {
            "name": "unist-util-visit",
            "version": "^1.3.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "ef08f89b0b76d0ed7312370543b20816",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "90305615-131b-5991-a708-2c2d1c43d946": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-smartypants",
      "id": "90305615-131b-5991-a708-2c2d1c43d946",
      "name": "gatsby-remark-smartypants",
      "version": "2.0.7",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-remark-smartypants",
      "packageJson": {
        "name": "gatsby-remark-smartypants",
        "description": "Use retext-smartypants to auto-enhance typography of markdown",
        "version": "2.0.7",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "smartypants"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "retext",
            "version": "^5.0.0"
          },
          {
            "name": "retext-smartypants",
            "version": "^3.0.0"
          },
          {
            "name": "unist-util-visit",
            "version": "^1.3.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "36d9425c7e53a69a4bf0b8f6838aecf1",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "da3d06eb-685e-5c77-ae1d-750eb6a2e4a9": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-transformer-sharp",
      "id": "da3d06eb-685e-5c77-ae1d-750eb6a2e4a9",
      "name": "gatsby-transformer-sharp",
      "version": "2.1.9",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onCreateNode",
        "setFieldsOnGraphQLNodeType",
        "onPreExtractQueries"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-transformer-sharp",
      "packageJson": {
        "name": "gatsby-transformer-sharp",
        "description": "Gatsby transformer plugin for images using Sharp",
        "version": "2.1.9",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "image",
          "sharp"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "fs-extra",
            "version": "^4.0.2"
          },
          {
            "name": "potrace",
            "version": "^2.1.1"
          },
          {
            "name": "probe-image-size",
            "version": "^4.0.0"
          },
          {
            "name": "sharp",
            "version": "^0.21.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": "^2.0.33"
          },
          {
            "name": "gatsby-plugin-sharp",
            "version": "^2.0.0-beta.3"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "0cfa5c839e14b2e4ab679d4911a6b2b8",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "84d6154d-4241-556c-a679-cc8339cac100": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-sharp",
      "id": "84d6154d-4241-556c-a679-cc8339cac100",
      "name": "gatsby-plugin-sharp",
      "version": "2.0.14",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onPreInit"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-sharp",
      "packageJson": {
        "name": "gatsby-plugin-sharp",
        "description": "Wrapper of the Sharp image manipulation library for Gatsby plugins",
        "version": "2.0.14",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "image",
          "sharp"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "async",
            "version": "^2.1.2"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "fs-exists-cached",
            "version": "^1.0.0"
          },
          {
            "name": "fs-extra",
            "version": "^7.0.0"
          },
          {
            "name": "imagemin",
            "version": "^6.0.0"
          },
          {
            "name": "imagemin-mozjpeg",
            "version": "^7.0.0"
          },
          {
            "name": "imagemin-pngquant",
            "version": "^6.0.0"
          },
          {
            "name": "imagemin-webp",
            "version": "^4.1.0"
          },
          {
            "name": "lodash",
            "version": "^4.17.10"
          },
          {
            "name": "mini-svg-data-uri",
            "version": "^1.0.0"
          },
          {
            "name": "potrace",
            "version": "^2.1.1"
          },
          {
            "name": "probe-image-size",
            "version": "^4.0.0"
          },
          {
            "name": "progress",
            "version": "^1.1.8"
          },
          {
            "name": "sharp",
            "version": "^0.21.0"
          },
          {
            "name": "svgo",
            "version": "^0.7.2"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "9fbac62876dbdc3eb1cd6d6529d2d7a7",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "74656790-483d-545c-a4b8-5b552a89d319": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-google-analytics",
      "id": "74656790-483d-545c-a4b8-5b552a89d319",
      "name": "gatsby-plugin-google-analytics",
      "version": "2.0.8",
      "pluginOptions": {
        "plugins": [],
        "trackingId": "UA-130227707-1"
      },
      "nodeAPIs": [],
      "browserAPIs": [
        "onRouteUpdate"
      ],
      "ssrAPIs": [
        "onRenderBody"
      ],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-google-analytics",
      "packageJson": {
        "name": "gatsby-plugin-google-analytics",
        "description": "Gatsby plugin to add google analytics onto a site",
        "version": "2.0.8",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "google analytics"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "fae319bb53e5a7a1c1ba6d32932c29a7",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "e1a9b6ff-843f-5a8b-b9fa-7ab223df58a2": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-feed",
      "id": "e1a9b6ff-843f-5a8b-b9fa-7ab223df58a2",
      "name": "gatsby-plugin-feed",
      "version": "2.0.10",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "onPostBuild"
      ],
      "browserAPIs": [],
      "ssrAPIs": [
        "onRenderBody"
      ],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-feed",
      "packageJson": {
        "name": "gatsby-plugin-feed",
        "description": "Creates an RSS feed for your Gatsby site.",
        "version": "2.0.10",
        "main": "index.js",
        "keywords": [
          "atom",
          "feed",
          "gatsby",
          "gatsby-plugin",
          "rss"
        ],
        "author": "Nicholas Young <nicholas@nicholaswyoung.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "lodash.merge",
            "version": "^4.6.0"
          },
          {
            "name": "mkdirp",
            "version": "^0.5.1"
          },
          {
            "name": "pify",
            "version": "^3.0.0"
          },
          {
            "name": "rss",
            "version": "^1.2.2"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "f6b9bc335a65e2134a776dbb8dfc4358",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "da8ce566-1185-5b0e-b1d5-4898dce3efa2": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-manifest",
      "id": "da8ce566-1185-5b0e-b1d5-4898dce3efa2",
      "name": "gatsby-plugin-manifest",
      "version": "2.0.11",
      "pluginOptions": {
        "plugins": [],
        "name": "Overreacted",
        "short_name": "Overreacted",
        "start_url": "/",
        "background_color": "#ffffff",
        "theme_color": "#ffa7c4",
        "display": "minimal-ui",
        "icon": "src/assets/icon.png"
      },
      "nodeAPIs": [
        "onPostBootstrap"
      ],
      "browserAPIs": [],
      "ssrAPIs": [
        "onRenderBody"
      ],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-manifest",
      "packageJson": {
        "name": "gatsby-plugin-manifest",
        "description": "Gatsby plugin which adds a manifest.webmanifest to make sites progressive web apps",
        "version": "2.0.11",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "favicon",
          "icons",
          "manifest.webmanifest",
          "progressive-web-app",
          "pwa"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "sharp",
            "version": "^0.21.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "7f39c379fc54bba19482b02179891e3e",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "1943ff2f-9c0c-558d-8d0c-006603e8106a": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-react-helmet",
      "id": "1943ff2f-9c0c-558d-8d0c-006603e8106a",
      "name": "gatsby-plugin-react-helmet",
      "version": "3.0.3",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [],
      "browserAPIs": [],
      "ssrAPIs": [
        "onRenderBody"
      ],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-react-helmet",
      "packageJson": {
        "name": "gatsby-plugin-react-helmet",
        "description": "Manage document head data with react-helmet. Provides drop-in server rendering support for Gatsby.",
        "version": "3.0.3",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "favicon",
          "react-helmet",
          "seo",
          "document",
          "head",
          "title",
          "meta",
          "link",
          "script",
          "base",
          "noscript",
          "style"
        ],
        "author": "Kyle Mathews <matthews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          },
          {
            "name": "react-helmet",
            "version": ">=5.1.3"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "fa26be7bf2cace2ba4a641ce5ebaf253",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "64059fc2-eafe-53ab-a542-ad6d70a5c7ff": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-typography",
      "id": "64059fc2-eafe-53ab-a542-ad6d70a5c7ff",
      "name": "gatsby-plugin-typography",
      "version": "2.2.2",
      "pluginOptions": {
        "plugins": [],
        "pathToConfigModule": "src/utils/typography"
      },
      "nodeAPIs": [
        "onPreBootstrap"
      ],
      "browserAPIs": [],
      "ssrAPIs": [
        "onRenderBody"
      ],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-typography",
      "packageJson": {
        "name": "gatsby-plugin-typography",
        "description": "Gatsby plugin to setup server rendering of Typography.js' CSS",
        "version": "2.2.2",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin",
          "typography",
          "typography.js"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.1.4"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          },
          {
            "name": "react-typography",
            "version": "^0.16.1 || ^1.0.0-alpha.0"
          },
          {
            "name": "typography",
            "version": "^0.16.0 || ^1.0.0-alpha.0"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "80316fd4c6e1c7768ef26a3543823a9f",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "7374ebf2-d961-52ee-92a2-c25e7cb387a9": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io",
      "id": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "name": "default-site-plugin",
      "version": "2f45c2831eb5a3c4e3e650cf120c57a8",
      "pluginOptions": {
        "plugins": []
      },
      "nodeAPIs": [
        "createPages",
        "onCreateNode"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io",
      "packageJson": {
        "name": "overreacted",
        "description": "Overreacted",
        "version": "1.0.0",
        "author": "Dan Abramov <dan.abramov@me.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "gatsby",
            "version": "^2.0.19"
          },
          {
            "name": "gatsby-plugin-feed",
            "version": "^2.0.8"
          },
          {
            "name": "gatsby-plugin-google-analytics",
            "version": "^2.0.5"
          },
          {
            "name": "gatsby-plugin-manifest",
            "version": "^2.0.5"
          },
          {
            "name": "gatsby-plugin-offline",
            "version": "^2.0.5"
          },
          {
            "name": "gatsby-plugin-react-helmet",
            "version": "^3.0.0"
          },
          {
            "name": "gatsby-plugin-sharp",
            "version": "^2.0.6"
          },
          {
            "name": "gatsby-plugin-typography",
            "version": "^2.2.0"
          },
          {
            "name": "gatsby-remark-copy-linked-files",
            "version": "^2.0.5"
          },
          {
            "name": "gatsby-remark-images",
            "version": "^2.0.4"
          },
          {
            "name": "gatsby-remark-prismjs",
            "version": "^3.0.0"
          },
          {
            "name": "gatsby-remark-responsive-iframe",
            "version": "^2.0.5"
          },
          {
            "name": "gatsby-remark-smartypants",
            "version": "^2.0.5"
          },
          {
            "name": "gatsby-source-filesystem",
            "version": "^2.0.2"
          },
          {
            "name": "gatsby-transformer-remark",
            "version": "^2.1.6"
          },
          {
            "name": "gatsby-transformer-sharp",
            "version": "^2.1.3"
          },
          {
            "name": "lodash",
            "version": "^4.17.11"
          },
          {
            "name": "prismjs",
            "version": "^1.15.0"
          },
          {
            "name": "react",
            "version": "^16.5.1"
          },
          {
            "name": "react-dom",
            "version": "^16.5.1"
          },
          {
            "name": "react-helmet",
            "version": "^5.2.0"
          },
          {
            "name": "react-typography",
            "version": "^0.16.13"
          },
          {
            "name": "typeface-merriweather",
            "version": "0.0.43"
          },
          {
            "name": "typeface-montserrat",
            "version": "0.0.43"
          },
          {
            "name": "typography",
            "version": "^0.16.17"
          },
          {
            "name": "typography-theme-wordpress-2016",
            "version": "^0.15.10"
          }
        ],
        "devDependencies": [
          {
            "name": "eslint",
            "version": "^4.19.1"
          },
          {
            "name": "eslint-plugin-react",
            "version": "^7.11.1"
          },
          {
            "name": "gh-pages",
            "version": "^1.2.0"
          },
          {
            "name": "prettier",
            "version": "^1.14.2"
          }
        ],
        "peerDependencies": [],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "7e5a7034d49d22f10f7c2728c9e0096b",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "de1454a8-036b-57ef-8599-4e481f13b079": {
      "resolve": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-page-creator",
      "id": "de1454a8-036b-57ef-8599-4e481f13b079",
      "name": "gatsby-plugin-page-creator",
      "version": "2.0.5",
      "pluginOptions": {
        "plugins": [],
        "path": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
        "pathCheck": false
      },
      "nodeAPIs": [
        "createPagesStatefully"
      ],
      "browserAPIs": [],
      "ssrAPIs": [],
      "pluginFilepath": "/Users/xuzhanhong1/study/overreacted.io/node_modules/gatsby-plugin-page-creator",
      "packageJson": {
        "name": "gatsby-plugin-page-creator",
        "description": "Gatsby plugin that automatically creates pages from React components in specified directories",
        "version": "2.0.5",
        "main": "index.js",
        "keywords": [
          "gatsby",
          "gatsby-plugin"
        ],
        "author": "Kyle Mathews <mathews.kyle@gmail.com>",
        "license": "MIT",
        "dependencies": [
          {
            "name": "@babel/runtime",
            "version": "^7.0.0"
          },
          {
            "name": "bluebird",
            "version": "^3.5.0"
          },
          {
            "name": "chokidar",
            "version": "^1.7.0"
          },
          {
            "name": "fs-exists-cached",
            "version": "^1.0.0"
          },
          {
            "name": "glob",
            "version": "^7.1.1"
          },
          {
            "name": "lodash",
            "version": "^4.17.10"
          },
          {
            "name": "micromatch",
            "version": "^3.1.10"
          },
          {
            "name": "parse-filepath",
            "version": "^1.0.1"
          },
          {
            "name": "slash",
            "version": "^1.0.0"
          }
        ],
        "devDependencies": [
          {
            "name": "@babel/cli",
            "version": "^7.0.0"
          },
          {
            "name": "@babel/core",
            "version": "^7.0.0"
          },
          {
            "name": "babel-preset-gatsby-package",
            "version": "^0.1.3"
          },
          {
            "name": "cross-env",
            "version": "^5.0.5"
          }
        ],
        "peerDependencies": [
          {
            "name": "gatsby",
            "version": ">2.0.0-alpha"
          }
        ],
        "optionalDependecies": [],
        "bundledDependecies": []
      },
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "852b28dfb0bc29cc20f3d40e9c4cb8d1",
        "type": "SitePlugin",
        "owner": "internal-data-bridge"
      }
    },
    "Site": {
      "siteMetadata": {
        "title": "酱香型猫砂盆",
        "author": "xuzhanhh",
        "description": "Personal blog by Dan Abramov. I explain with words and code.",
        "siteUrl": "https://overreacted.io",
        "social": {
          "twitter": "@gaeron"
        }
      },
      "pathPrefix": "",
      "polyfill": true,
      "buildTime": "2019-03-18T06:49:12.200Z",
      "id": "Site",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "contentDigest": "8dd2e46b906e5e1e46d6c46508852e5e",
        "type": "Site",
        "owner": "internal-data-bridge"
      }
    },
    "7f66430e-95ee-5784-9689-7e21bb30385f": {
      "id": "7f66430e-95ee-5784-9689-7e21bb30385f",
      "children": [],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "724dc3c8f1af6fe20b4ef17794f08f00",
        "type": "Directory",
        "description": "Directory \"src/pages\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "relativePath": "",
      "extension": "",
      "size": 416,
      "prettySize": "416 B",
      "modifiedTime": "2019-03-18T06:23:47.308Z",
      "accessTime": "2019-03-18T06:49:16.898Z",
      "changeTime": "2019-03-18T06:23:47.308Z",
      "birthTime": "2018-12-12T16:04:16.013Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src",
      "base": "pages",
      "ext": "",
      "name": "pages",
      "relativeDirectory": "..",
      "dev": 16777220,
      "mode": 16877,
      "nlink": 13,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4096,
      "ino": 12669793,
      "blocks": 0,
      "atimeMs": 1552891756897.5264,
      "mtimeMs": 1552890227307.5005,
      "ctimeMs": 1552890227307.5005,
      "birthtimeMs": 1544630656012.8213,
      "atime": "2019-03-18T06:49:16.898Z",
      "mtime": "2019-03-18T06:23:47.308Z",
      "ctime": "2019-03-18T06:23:47.308Z",
      "birthtime": "2018-12-12T16:04:16.013Z"
    },
    "86ce4482-5854-58cb-aa03-bcc2906a61ea": {
      "id": "86ce4482-5854-58cb-aa03-bcc2906a61ea",
      "children": [
        "55557a74-de54-5683-bd78-3de2108f3ce8"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "6f55284090486e26b4cd6f20735d0324",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/Inside Fiber.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/Inside Fiber.md",
      "relativePath": "Inside Fiber.md",
      "extension": "md",
      "size": 13216,
      "prettySize": "13.2 kB",
      "modifiedTime": "2018-12-22T07:09:07.635Z",
      "accessTime": "2019-03-18T06:22:15.910Z",
      "changeTime": "2019-03-05T06:27:19.274Z",
      "birthTime": "2018-12-14T07:01:39.661Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "Inside Fiber.md",
      "ext": ".md",
      "name": "Inside Fiber",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4096,
      "ino": 13372526,
      "blocks": 32,
      "atimeMs": 1552890135909.627,
      "mtimeMs": 1545462547634.6165,
      "ctimeMs": 1551767239274.265,
      "birthtimeMs": 1544770899660.6099,
      "atime": "2019-03-18T06:22:15.910Z",
      "mtime": "2018-12-22T07:09:07.635Z",
      "ctime": "2019-03-05T06:27:19.274Z",
      "birthtime": "2018-12-14T07:01:39.661Z"
    },
    "b767f2c2-e388-50f4-8212-63aec759cf47": {
      "id": "b767f2c2-e388-50f4-8212-63aec759cf47",
      "children": [],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "f37fda6645715a1a93b142a5f146ef35",
        "type": "File",
        "mediaType": "application/javascript",
        "description": "File \"src/pages/index.js\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/index.js",
      "relativePath": "index.js",
      "extension": "js",
      "size": 2048,
      "prettySize": "2.05 kB",
      "modifiedTime": "2018-12-12T16:13:06.021Z",
      "accessTime": "2018-12-14T06:16:16.531Z",
      "changeTime": "2018-12-12T16:13:06.021Z",
      "birthTime": "2018-12-12T16:04:16.014Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "index.js",
      "ext": ".js",
      "name": "index",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4194304,
      "ino": 12669797,
      "blocks": 8,
      "atimeMs": 1544768176531.2156,
      "mtimeMs": 1544631186021.2659,
      "ctimeMs": 1544631186021.2659,
      "birthtimeMs": 1544630656013.689,
      "atime": "2018-12-14T06:16:16.531Z",
      "mtime": "2018-12-12T16:13:06.021Z",
      "ctime": "2018-12-12T16:13:06.021Z",
      "birthtime": "2018-12-12T16:04:16.014Z"
    },
    "e8ec8119-272f-5ede-9062-62d6d04ec767": {
      "id": "e8ec8119-272f-5ede-9062-62d6d04ec767",
      "children": [
        "8b5a4b64-a89e-5d42-a386-121a4aeb1e1d"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "616fa54d30653d0e03c287fed11c416c",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/learning A Cartoon to Fiber.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/learning A Cartoon to Fiber.md",
      "relativePath": "learning A Cartoon to Fiber.md",
      "extension": "md",
      "size": 12165,
      "prettySize": "12.2 kB",
      "modifiedTime": "2018-12-12T16:31:06.351Z",
      "accessTime": "2018-12-12T16:32:27.617Z",
      "changeTime": "2018-12-12T16:31:06.351Z",
      "birthTime": "2018-11-10T12:12:19.979Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "learning A Cartoon to Fiber.md",
      "ext": ".md",
      "name": "learning A Cartoon to Fiber",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4194304,
      "ino": 12709591,
      "blocks": 24,
      "atimeMs": 1544632347616.597,
      "mtimeMs": 1544632266350.997,
      "ctimeMs": 1544632266350.997,
      "birthtimeMs": 1541851939978.5884,
      "atime": "2018-12-12T16:32:27.617Z",
      "mtime": "2018-12-12T16:31:06.351Z",
      "ctime": "2018-12-12T16:31:06.351Z",
      "birthtime": "2018-11-10T12:12:19.979Z"
    },
    "457e1448-0238-5a66-aff8-18835b352611": {
      "id": "457e1448-0238-5a66-aff8-18835b352611",
      "children": [
        "351744df-b3d1-5265-a694-9e77f722426e"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "12eafdaa95738e2270f075d7bb7f0ad0",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/react hooks@seb.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/react hooks@seb.md",
      "relativePath": "react hooks@seb.md",
      "extension": "md",
      "size": 7469,
      "prettySize": "7.47 kB",
      "modifiedTime": "2018-12-12T16:26:17.882Z",
      "accessTime": "2018-12-14T06:16:16.532Z",
      "changeTime": "2018-12-12T16:26:17.882Z",
      "birthTime": "2018-12-04T11:56:26.700Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "react hooks@seb.md",
      "ext": ".md",
      "name": "react hooks@seb",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4194304,
      "ino": 12708967,
      "blocks": 16,
      "atimeMs": 1544768176532.3567,
      "mtimeMs": 1544631977882.4976,
      "ctimeMs": 1544631977882.4976,
      "birthtimeMs": 1543924586700.4119,
      "atime": "2018-12-14T06:16:16.532Z",
      "mtime": "2018-12-12T16:26:17.882Z",
      "ctime": "2018-12-12T16:26:17.882Z",
      "birthtime": "2018-12-04T11:56:26.700Z"
    },
    "96f4be9a-0dc7-5d6a-8d1a-bdbfe6a54723": {
      "id": "96f4be9a-0dc7-5d6a-8d1a-bdbfe6a54723",
      "children": [],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "1ee54ca3bbc62ba450ac224f4f06695f",
        "type": "File",
        "mediaType": "application/javascript",
        "description": "File \"src/pages/404.js\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js",
      "relativePath": "404.js",
      "extension": "js",
      "size": 666,
      "prettySize": "666 B",
      "modifiedTime": "2018-12-12T16:04:16.013Z",
      "accessTime": "2018-12-12T16:04:16.056Z",
      "changeTime": "2018-12-12T16:04:16.013Z",
      "birthTime": "2018-12-12T16:04:16.013Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "404.js",
      "ext": ".js",
      "name": "404",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4194304,
      "ino": 12669794,
      "blocks": 8,
      "atimeMs": 1544630656056.4028,
      "mtimeMs": 1544630656012.924,
      "ctimeMs": 1544630656012.924,
      "birthtimeMs": 1544630656012.8677,
      "atime": "2018-12-12T16:04:16.056Z",
      "mtime": "2018-12-12T16:04:16.013Z",
      "ctime": "2018-12-12T16:04:16.013Z",
      "birthtime": "2018-12-12T16:04:16.013Z"
    },
    "af562c41-a48f-5b7c-b2db-cced04ba9be3": {
      "id": "af562c41-a48f-5b7c-b2db-cced04ba9be3",
      "children": [
        "d16d8354-6f61-5f1a-ad48-bd02309a1329"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "24857a13887f14cff969674681ae750c",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/Promise.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/Promise.md",
      "relativePath": "Promise.md",
      "extension": "md",
      "size": 4372,
      "prettySize": "4.37 kB",
      "modifiedTime": "2018-12-12T16:30:22.920Z",
      "accessTime": "2018-12-12T16:32:27.616Z",
      "changeTime": "2018-12-12T16:30:22.920Z",
      "birthTime": "2018-07-18T08:53:02.708Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "Promise.md",
      "ext": ".md",
      "name": "Promise",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4194304,
      "ino": 12709468,
      "blocks": 16,
      "atimeMs": 1544632347615.9578,
      "mtimeMs": 1544632222919.77,
      "ctimeMs": 1544632222919.77,
      "birthtimeMs": 1531903982708.1873,
      "atime": "2018-12-12T16:32:27.616Z",
      "mtime": "2018-12-12T16:30:22.920Z",
      "ctime": "2018-12-12T16:30:22.920Z",
      "birthtime": "2018-07-18T08:53:02.708Z"
    },
    "351744df-b3d1-5265-a694-9e77f722426e": {
      "id": "351744df-b3d1-5265-a694-9e77f722426e",
      "children": [],
      "parent": "457e1448-0238-5a66-aff8-18835b352611",
      "internal": {
        "content": "\n翻译这个 [issue](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)\n\n## 注入模型\n\n​\t基本上，争论分解为想要交换(swap out)实现钩子的代码(the code that implements the hooks)。这类似于一般依赖注入和控制问题的反转(inversion of control problem)。React没有自己的依赖注入系统（不同于Angular）。通常他不需要这个因为大多数入口都是pull而不是push。对于其他代码，模块系统已经提供了良好的依赖注入边界，对于测试，我们倾向于推荐其他技术，例如在模块系统级别进行模拟（例如使用jest）\n\n​\t一些例外是像setState, replaceState, isMounted, findDOMNode, batchedUpdates等API，一个小的事实是React已经使用依赖注入将“updater”插入到Component base class。这是构造函数的第三个参数。该组件实际上不需要做任何事情。这就是让React在React ART或React Test Renderer等相同环境中的不同版本中具有多种不同类型的渲染器实现的原因。 自定义渲染器已经利用了这一点。\n\n```javascript\nimport ReactNoopUpdateQueue from './ReactNoopUpdateQueue';\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n```\n\n​\t理论上，像React-clones这样的第三方库可以使用updater来注入他们的实现。实践中，大部分倾向于使用module shimming来替换整个react模块，因为他们有权衡或者想要实现其他API（例如， 移除dev模式内容或者将base classes和实现细节合并）\n\n​\t这些选项仍然保留在hooks的程序中。hooks的实现实际上没有在react包中实现，它只是调用当前的“调度程序”（dispatcher）。就如我上面解释的那样，可以暂时覆盖任何给定点的实现。这就是react渲染器（renderers）让多个渲染器共享相同API。例如，你可以让一个钩子测试调度程序（hooks test dispatcher）只是为了单元测试hooks。目前他有一个看起来很可怕的名字不过我们可以很容器的改变这个名词，这不是设计的缺陷（flaw of the design）。现在“调度程序（dispatcher）”可以移动到用户空间中，但是这会增加额外的噪音，这些噪音几乎从来不与单个组件的作者相关（but this adds additional noise for something that almost never is relevant to the author of an individual component），就像大多数人不知道React中的updater一样。\n\n​\t总的来说，我们可能会使用更多的静态函数调用因为他们更适合tree-shaking和更好地优化和内联。\n\n​\t另一个问题是hooks的主入口在react包中而不是第三方包，在未来很有可能其他代码会移除react包所以hooks会是剩下的大部分内容，所以包体积不需要担心。唯一的问题是hooks属于react下的而不是更通用的。例如，Vue曾经考虑过hooks API。但是hooks的关键是其原函数我们已经定义好的。这与Vue有完全不同的原函数。我们已经迭代了我们的函数。其他库可能会提出略有不同的原函数。在这一点上，过早地使这些过于笼统是没有意义的。第一次迭代在react包上的事实只是为了说明这就是我们对原函数的看法。如果存在重叠，那么就没有什么能阻止我们在第三方命名包上与其他库进行整合，并将反应的那些转发到该包。\n\n## 依赖持续调用顺序\n\n​\t要明确的是，执行顺序的依赖并不是我们真正想要的。 首先放置useState或useEffect或类似的东西并不重要。React有很多依赖于执行顺序的模式，只是因为在渲染中允许变异（这仍然使渲染本身变得纯净）。\n\n```javascript\nlet count = 0;\n\nlet children = items.map(item => {\n  count++;\n  return <Item item={item} key={item.id} />;\n});\n\nlet header = <Header>Number of items {count}</Header>;\n```\n\n​\t我不能在我的代码中只改变children和header的顺序。\n\n​\thooks不关心使用的顺序，它关系是否有持续每次都一样的顺序。这与调用之间隐含的依赖性非常不同。\n\n​\t最好不要依赖持久秩序 - 所有事情都是平等的。 但是，有一些权衡。 例如。 语法噪音或其他令人困惑的事情。\n\n​\tSome think that it is worth the cost for puritism reasons alone. However, some also have practical concerns.\n\n\n\n## API设计\n\n### useReducer\n\n```javascript\nconst initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'reset':\n      return initialState;\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      // A reducer must always return a valid state.\n      // Alternatively you can throw an error if an invalid action is dispatched.\n      return state;\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(reducer, {count: initialCount});\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'reset'})}>\n        Reset\n      </button>\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n    </>\n  );\n}\n```\n\n这个会替换Redux吗？这回加重学习flux的负担吗？一般来说比起很多flux框架，Reducer是一个更狭隘的用例，Reducer非常简单，但是，如果你在学习Vue，Reason，Elm等框架/语言，调度和集中逻辑以在更高级别的状态之间转换的这种一般模式似乎取得了巨大成功。它还解决了React中带有回调的许多怪癖，为复杂的状态转换带来了更多直观的解决方案。特别是在并行（concurrent）的世界中。\n\n从代码体积上看，他不会增加任何非当前必须的代码，从概念上，我认为这是一个值得学习的概念，因为相同的模式不断以各种形式出现在各处。 最好有一个中央API来管理它。\n\n所以我认为比起useState，useReducer是更加核心的API。但是useState依然很棒因为对于简单的用例来说它非常简洁而且简易解释，不过大家应该尽早研究useReducer或其他相似的模式。\n\n也就是说，它也没有做Redux和其他Flux框架所做的很多事情。通常我认为你不会需要它，所以它可能不像现在那样普遍存在，但它仍然存在。\n\n### Context Provider\n\n\n\n### useEffect\n\n目前最奇怪的Hook是`useEffect`。需要明确的是，预计这是迄今为止最难使用的Hook，因为它正在使用命令式代码（interoping with imperative code）。命令式代码很难管理，这就是为什么我们试图保持声明式代码。但是，从声明式变为命令式很难，因为声明式可以处理更多不同类型的状态和每行代码的转换。 实现效果时，理想情况下也应处理所有这些情况。 这里的部分目标是鼓励处理更多情况。 如果这样做，那么一些怪癖是可以的。",
        "type": "MarkdownRemark",
        "contentDigest": "d8c15aa6dea77d9ed3d0484bb25af5e8",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "react hooks@seb",
        "date": "2018-12-11",
        "spoiler": "随手翻译，我觉得dan会用人话再说一遍的。",
        "_PARENT": "457e1448-0238-5a66-aff8-18835b352611"
      },
      "excerpt": "",
      "rawMarkdownBody": "\n翻译这个 [issue](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)\n\n## 注入模型\n\n​\t基本上，争论分解为想要交换(swap out)实现钩子的代码(the code that implements the hooks)。这类似于一般依赖注入和控制问题的反转(inversion of control problem)。React没有自己的依赖注入系统（不同于Angular）。通常他不需要这个因为大多数入口都是pull而不是push。对于其他代码，模块系统已经提供了良好的依赖注入边界，对于测试，我们倾向于推荐其他技术，例如在模块系统级别进行模拟（例如使用jest）\n\n​\t一些例外是像setState, replaceState, isMounted, findDOMNode, batchedUpdates等API，一个小的事实是React已经使用依赖注入将“updater”插入到Component base class。这是构造函数的第三个参数。该组件实际上不需要做任何事情。这就是让React在React ART或React Test Renderer等相同环境中的不同版本中具有多种不同类型的渲染器实现的原因。 自定义渲染器已经利用了这一点。\n\n```javascript\nimport ReactNoopUpdateQueue from './ReactNoopUpdateQueue';\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n```\n\n​\t理论上，像React-clones这样的第三方库可以使用updater来注入他们的实现。实践中，大部分倾向于使用module shimming来替换整个react模块，因为他们有权衡或者想要实现其他API（例如， 移除dev模式内容或者将base classes和实现细节合并）\n\n​\t这些选项仍然保留在hooks的程序中。hooks的实现实际上没有在react包中实现，它只是调用当前的“调度程序”（dispatcher）。就如我上面解释的那样，可以暂时覆盖任何给定点的实现。这就是react渲染器（renderers）让多个渲染器共享相同API。例如，你可以让一个钩子测试调度程序（hooks test dispatcher）只是为了单元测试hooks。目前他有一个看起来很可怕的名字不过我们可以很容器的改变这个名词，这不是设计的缺陷（flaw of the design）。现在“调度程序（dispatcher）”可以移动到用户空间中，但是这会增加额外的噪音，这些噪音几乎从来不与单个组件的作者相关（but this adds additional noise for something that almost never is relevant to the author of an individual component），就像大多数人不知道React中的updater一样。\n\n​\t总的来说，我们可能会使用更多的静态函数调用因为他们更适合tree-shaking和更好地优化和内联。\n\n​\t另一个问题是hooks的主入口在react包中而不是第三方包，在未来很有可能其他代码会移除react包所以hooks会是剩下的大部分内容，所以包体积不需要担心。唯一的问题是hooks属于react下的而不是更通用的。例如，Vue曾经考虑过hooks API。但是hooks的关键是其原函数我们已经定义好的。这与Vue有完全不同的原函数。我们已经迭代了我们的函数。其他库可能会提出略有不同的原函数。在这一点上，过早地使这些过于笼统是没有意义的。第一次迭代在react包上的事实只是为了说明这就是我们对原函数的看法。如果存在重叠，那么就没有什么能阻止我们在第三方命名包上与其他库进行整合，并将反应的那些转发到该包。\n\n## 依赖持续调用顺序\n\n​\t要明确的是，执行顺序的依赖并不是我们真正想要的。 首先放置useState或useEffect或类似的东西并不重要。React有很多依赖于执行顺序的模式，只是因为在渲染中允许变异（这仍然使渲染本身变得纯净）。\n\n```javascript\nlet count = 0;\n\nlet children = items.map(item => {\n  count++;\n  return <Item item={item} key={item.id} />;\n});\n\nlet header = <Header>Number of items {count}</Header>;\n```\n\n​\t我不能在我的代码中只改变children和header的顺序。\n\n​\thooks不关心使用的顺序，它关系是否有持续每次都一样的顺序。这与调用之间隐含的依赖性非常不同。\n\n​\t最好不要依赖持久秩序 - 所有事情都是平等的。 但是，有一些权衡。 例如。 语法噪音或其他令人困惑的事情。\n\n​\tSome think that it is worth the cost for puritism reasons alone. However, some also have practical concerns.\n\n\n\n## API设计\n\n### useReducer\n\n```javascript\nconst initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'reset':\n      return initialState;\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      // A reducer must always return a valid state.\n      // Alternatively you can throw an error if an invalid action is dispatched.\n      return state;\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(reducer, {count: initialCount});\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'reset'})}>\n        Reset\n      </button>\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n    </>\n  );\n}\n```\n\n这个会替换Redux吗？这回加重学习flux的负担吗？一般来说比起很多flux框架，Reducer是一个更狭隘的用例，Reducer非常简单，但是，如果你在学习Vue，Reason，Elm等框架/语言，调度和集中逻辑以在更高级别的状态之间转换的这种一般模式似乎取得了巨大成功。它还解决了React中带有回调的许多怪癖，为复杂的状态转换带来了更多直观的解决方案。特别是在并行（concurrent）的世界中。\n\n从代码体积上看，他不会增加任何非当前必须的代码，从概念上，我认为这是一个值得学习的概念，因为相同的模式不断以各种形式出现在各处。 最好有一个中央API来管理它。\n\n所以我认为比起useState，useReducer是更加核心的API。但是useState依然很棒因为对于简单的用例来说它非常简洁而且简易解释，不过大家应该尽早研究useReducer或其他相似的模式。\n\n也就是说，它也没有做Redux和其他Flux框架所做的很多事情。通常我认为你不会需要它，所以它可能不像现在那样普遍存在，但它仍然存在。\n\n### Context Provider\n\n\n\n### useEffect\n\n目前最奇怪的Hook是`useEffect`。需要明确的是，预计这是迄今为止最难使用的Hook，因为它正在使用命令式代码（interoping with imperative code）。命令式代码很难管理，这就是为什么我们试图保持声明式代码。但是，从声明式变为命令式很难，因为声明式可以处理更多不同类型的状态和每行代码的转换。 实现效果时，理想情况下也应处理所有这些情况。 这里的部分目标是鼓励处理更多情况。 如果这样做，那么一些怪癖是可以的。",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/react hooks@seb.md",
      "fields": {
        "slug": "/react hooks@seb/"
      }
    },
    "8b5a4b64-a89e-5d42-a386-121a4aeb1e1d": {
      "id": "8b5a4b64-a89e-5d42-a386-121a4aeb1e1d",
      "children": [],
      "parent": "e8ec8119-272f-5ede-9062-62d6d04ec767",
      "internal": {
        "content": "\n## 这里我还没写完\n\n![image-20181110201732613](/Users/xuzhanhong1/Documents/image-20181110201732613.png)\n\n\n\n![image-20181110202214457](/Users/xuzhanhong1/Documents/image-20181110202214457.png)\n\n\n\n![image-20181110203945805](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110203945805.png)\n\n## stack reconciler的缺点\n\n​\t在我们执行update操作之前我们已经有一个在初始render时已经构造好的fiber树，react也会开始work-in-progress树并添加第一个fiber节点，因为我们不想当我们计算变动时直接修改dom，这个跟stack reconciler不一样，stack reconciler在往下走改变实例时同时改动当前的dom节点。\n\n​\t例如在将实例2变成4时，同时也会改动dom node从2到4在react计算第三个实例应该从3变到9前。\n\n![image-20181110204749728](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110204749728.png)\n\n这样子是可行的如果你一次性同步地完成所有事情。如果你需要在两个实例间打断时，浏览器需要时间paint和layout，但是只有2变成4而3没有变成9，这样你的ui就会变得不连续。\n\n\n\n## fiber phases\n\n第一个阶段，react只会构建fiber tree和work-in-progress tree和变动列表（可中断）\n\n第二阶段，将这些变动作用到dom上（不可中断）\n\n![image-20181110205919129](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110210012223.png)\n\n\n\n## 阶段1\n\n1. 当我们点击按钮时触发了setState\n\n![image-20181110210205135](/Users/xuzhanhong1/Documents/image-20181110210205135.png)\n\n2. 当setState被调用时，react会添加List组件一系列更新添加到更新队列中，然后react会开始调度这些工作![image-20181110210528429](/Users/xuzhanhong1/Documents/image-20181110210528429.png)\n\n3. 使用request idle callback去延迟完成这些工作 \n\n   ![image-20181110210741530](/Users/xuzhanhong1/Documents/image-20181110210741530.png)\n\n   当主线程有空闲时间时会把具体剩余时间给react，具体几毫秒到几十毫秒（当最近的将来没有frame scheduled时）\n\n   ![image-20181110211003501](/Users/xuzhanhong1/Documents/image-20181110211003501.png)\n\n   ​\t这样react可以使用这些剩余时间处理更新并当其他工作需要处理时将时间还给主线程。这样的操作需要跟踪两个时间，next unit of work that it needs to work on 和 主线程给与的剩余时间\n\n   ![image-20181110211302791](/Users/xuzhanhong1/Documents/image-20181110211302791.png)\n\n4. 从current复制HostRoot的数据到workInProgress tree 并添加一个指针指向儿子（List）\n\n   ![image-20181110211949517](/Users/xuzhanhong1/Documents/image-20181110211949517.png)\n\n5. 因为List本身没有更新，所以将List复制到workInProgress tree。并且List有更新队列，所以也会复制update Queue。\n\n   ![image-20181110212258539](/Users/xuzhanhong1/Documents/image-20181110212258539.png)\n\n6. 所以List fiber is going to be returned as the next unit of work![image-20181110212347964](/Users/xuzhanhong1/Documents/image-20181110212347964.png)\n\n7. React 会检查deadline是否到来。因为还有剩余的时间，react会继续处理List![image-20181110212645386](/Users/xuzhanhong1/Documents/image-20181110212645386.png)\n\n8. 因为List有更新队列，所以react会处理这些更新，他会调用updater函数，且传对象的setState以后的某个版本被移除![image-20181110212849733](/Users/xuzhanhong1/Documents/image-20181110212849733.png)并结束处理更新队列，fiber会标记一个tag表示他会修改dom树![image-20181110213110874](/Users/xuzhanhong1/Documents/image-20181110213110874.png)\n\n9. 在继续往下处理前，我们需要知道List的children，所以react会在List实例设置props和state并调用render，我们会得到一个数组的元素。react会遍历这些元素去判断在current tree中是否有可以重用的fiber。如果有，则直接复制\n\n   ![image-20181110213813900](/Users/xuzhanhong1/Documents/image-20181110213813900.png)\n\n   ![image-20181110213944644](/Users/xuzhanhong1/Documents/image-20181110213944644.png)\n\n10. 然后会返回List的第一个child button作为下一个unit of work, 然后react会回到work loop并检查deadline。![image-20181110214543420](/Users/xuzhanhong1/Documents/image-20181110214543420.png)![image-20181110214728829](/Users/xuzhanhong1/Documents/image-20181110214728829.png)\n\n11. 这个时候用户想搞事情，点击放大字体按钮去改变web字体大小![image-20181110214856489](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110214856489.png)\n\n12. 这样会导致给队列中的一些东西添加了一个回调，主线程需要去关心的，但是不是马上因为react仍然有时间继续处理next unit of work -- button。button是我们第一个遇到的没有孩子的元素，所以他不会创建新的工作。所以react可以完成这个单位的工作，这意味着比较新旧元素查看是否有变动，如果有变动需要变动dom则会标记。然后因为button没有孩子，所以会返回邻居作为下一个单位的工作![image-20181110215513582](/Users/xuzhanhong1/Documents/image-20181110215513582.png)\n\n13. react会结束这个单元的工作并回到work loop中检查deadline![image-20181110215657530](/Users/xuzhanhong1/Documents/image-20181110215657530.png)\n\n14. item中有sCU，并且因为sCU返回false所以item1不需要对dom进行修改，所以不需要打标签。然后邻居作为下一个单元的工作。同样地，react回到work loop检查deadline并回来![image-20181110215823086](/Users/xuzhanhong1/Documents/image-20181110215823086.png)\n\n15. 第二个item的sCU返回true，所以会被标记为有更变，然后他的div会被复制过来，并且将div返回作为下一个单元的工作 \n    ![image-20181110220630861](/Users/xuzhanhong1/Documents/image-20181110220630861.png)![image-20181110220704324](/Users/xuzhanhong1/Documents/image-20181110220704324.png)\n\n    \n\n16.  因为我们还有一丢丢时间所以我们准备处理这个div，因为这个div没有children所以我们可以完成它，我们发现这个div的内容变更了，所以我们给他打上标记\n    ![image-20181110222222665](/Users/xuzhanhong1/Documents/image-20181110222423364.png)\n\n17. 因为当前没有邻居也没有children，没有下个单元的工作，所以会调用他父亲的complete，并且这是我们第一次将变动添加到一个列表，因为他有tag且完成了(completed)。\n    ![image-20181110224035848](/Users/xuzhanhong1/Documents/image-20181110224035848.png)\n\n18. 这个时候item也完成了(complated)并且他也有一个tag。so it's going to move itself up to it's going to start creating this list of changes on its parent. It merge its own list of changes into the parents effect list\n\n19. item会将div的变动放到effect list的第一个，然后将自己放到effect list的末尾\n    ![image-20181110224526544](/Users/xuzhanhong1/Documents/image-20181110224526544.png)\n\n20. 第二个item complete 并返回邻居作为下一个单元的工作![image-20181110224637609](/Users/xuzhanhong1/Documents/image-20181110224637609.png)\n\n    返回work loop，react发现deadline已经到了。所以react会释放资源并让主线程处理其他任务\n\n    ![image-20181110224810666](/Users/xuzhanhong1/Documents/image-20181110224810666.png)\n\n    react仍然需要继续完成任务，所以使用rIC让主线程完成工作后继续调用react\n\n    ![image-20181110224939741](/Users/xuzhanhong1/Documents/image-20181110224939741.png)\n\n    然后主线程会去处理等待中的callback，在这个例子中是layout\n\n    ![image-20181110225030973](/Users/xuzhanhong1/Documents/image-20181110225030973.png)\n\n    不过注意到nothing in the content of our react app is changed even though react note says going to need to change two to four 在将来的某个时间，而不是现在。\n\n    \n\n21. main thread 处理完其他事情会继续调用react，最后两个单元工作和第二个item一样\n\n    ![image-20181110225617532](/Users/xuzhanhong1/Documents/image-20181110225617532.png)\n    ![image-20181110225632116](/Users/xuzhanhong1/Documents/image-20181110225632116.png)\n\n即完成了List下面的所有单元工作，所以List可以调用complete，并将自己和孩子的更变放到effect list中，然后HostRoot也完成了\n![image-20181110225715325](/Users/xuzhanhong1/Documents/image-20181110230128716.png)\n![image-20181110225807413](/Users/xuzhanhong1/Documents/image-20181110225807413.png)\n\n\n\n22. react会将work-in-progress tree设成pending commit，这意味着第一个阶段结束了。我们更新了work-in-progress tree和指出了变动列表\n\n\n\n## 阶段2\n\n1. react 会检查deadline判断是否有时间立刻执行commit，如果不够则在rIC后第一时间commit这个pending commit![image-20181110230504330](/Users/xuzhanhong1/Documents/image-20181110230504330.png)\n2. react会遍历effect list并应该更变到dom上，从第一个fiber开始\n\n![image-20181110230821602](/Users/xuzhanhong1/Documents/image-20181110230821602.png)\n![image-20181110230855909](/Users/xuzhanhong1/Documents/image-20181110230855909.png)\n![image-20181110230913246](/Users/xuzhanhong1/Documents/image-20181110230913246.png)\nitem没有任何改变，因为我们不使用ref，不过如果我们在item中有ref will be detached now and then it would be reattached later\n![image-20181110231153619](/Users/xuzhanhong1/Documents/image-20181110231153619.png)\n![image-20181110231121156](/Users/xuzhanhong1/Documents/image-20181110231121156.png)\n现在所有变动都在第一阶段计算完毕并commit到dom树。这意味着work-in-progress tree is actually a more up-to-date version of state of the app than the current tree，所以react需要修复current tree。他会切换指针，所以当前指针指向我们刚构建的work-in-pregress tree\n![image-20181110231429089](/Users/xuzhanhong1/Documents/image-20181110231429089.png)\n![image-20181110231630674](/Users/xuzhanhong1/Documents/image-20181110231630674.png)\n这意味着react可以在work-in-progress tree中重用旧对象，只需要在下次构建中work-in-progress tree复制key value。这叫double buffering，可以在内存分配和gc中节省时间，现在react完成了这次的commit，并执行剩下的lifecycle hooks和更新任何refs并处理error boundaries\n![image-20181110232043775](/Users/xuzhanhong1/Documents/image-20181110232043775.png)\n\n## 优先级\n\n```javascript\n{\n    \"Synchronous\": \"same as stack rec\",\n    \"Task\": \"before next tick\",\n    \"Animation\": \"before next frame\",\n     \"rIC\":{\n        \t\"High\":\"pretty soon\",\n            \"Low\":\"如数据获取，对100or200ms不敏感\",\n\t\t\t\"Offscreen\": \"prep for display/scroll\"\n        }\n}\n```\n\n高优先级的任务会立刻执行，尽管现在已经开始了低优先级的任务\n\n![image-20181110232753533](/Users/xuzhanhong1/Documents/image-20181110232753533.png)\n\n回到之前我们搞事情的地方，如果我们有一个紧急的font resize button\n![image-20181110233032279](/Users/xuzhanhong1/Documents/image-20181110233032279.png)\n\n用户点击后会放置一个callback到主线程处理队列中\n\n\n\n\n\n\n\n## lifecycle hook during the phase\n\n![image-20181111143014786](/Users/xuzhanhong1/Documents/image-20181111143014786.png)\n\n![image-20181111143107194](/Users/xuzhanhong1/Documents/image-20181111143107194.png)\n\n\n\n## starvation\n\nreusing work where it can. So if it had a low priority work that was done and the high priority work didn't touch that part of the tree then they can reuse that work.\n\n![image-20181111143219524](/Users/xuzhanhong1/Documents/image-20181111143219524.png)\n\n\n\n## 相关资料\n\n[effectTag](http://link.zhihu.com/?target=https%3A//github.com/facebook/react/blob/master/packages/shared/ReactSideEffectTags.js)\n\n[react custom rIC](https://github.com/facebook/react/blob/0154a79fedef38a824a837c535bc853013dd4588/packages/react-scheduler/src/ReactScheduler.js#L25-L31)\n\n",
        "type": "MarkdownRemark",
        "contentDigest": "6c796db21a5c3323967878c074ea3c18",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "learning A Cartoon to Fiber",
        "date": "2018-11-11",
        "spoiler": "学习记录",
        "_PARENT": "e8ec8119-272f-5ede-9062-62d6d04ec767"
      },
      "excerpt": "",
      "rawMarkdownBody": "\n## 这里我还没写完\n\n![image-20181110201732613](/Users/xuzhanhong1/Documents/image-20181110201732613.png)\n\n\n\n![image-20181110202214457](/Users/xuzhanhong1/Documents/image-20181110202214457.png)\n\n\n\n![image-20181110203945805](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110203945805.png)\n\n## stack reconciler的缺点\n\n​\t在我们执行update操作之前我们已经有一个在初始render时已经构造好的fiber树，react也会开始work-in-progress树并添加第一个fiber节点，因为我们不想当我们计算变动时直接修改dom，这个跟stack reconciler不一样，stack reconciler在往下走改变实例时同时改动当前的dom节点。\n\n​\t例如在将实例2变成4时，同时也会改动dom node从2到4在react计算第三个实例应该从3变到9前。\n\n![image-20181110204749728](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110204749728.png)\n\n这样子是可行的如果你一次性同步地完成所有事情。如果你需要在两个实例间打断时，浏览器需要时间paint和layout，但是只有2变成4而3没有变成9，这样你的ui就会变得不连续。\n\n\n\n## fiber phases\n\n第一个阶段，react只会构建fiber tree和work-in-progress tree和变动列表（可中断）\n\n第二阶段，将这些变动作用到dom上（不可中断）\n\n![image-20181110205919129](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110210012223.png)\n\n\n\n## 阶段1\n\n1. 当我们点击按钮时触发了setState\n\n![image-20181110210205135](/Users/xuzhanhong1/Documents/image-20181110210205135.png)\n\n2. 当setState被调用时，react会添加List组件一系列更新添加到更新队列中，然后react会开始调度这些工作![image-20181110210528429](/Users/xuzhanhong1/Documents/image-20181110210528429.png)\n\n3. 使用request idle callback去延迟完成这些工作 \n\n   ![image-20181110210741530](/Users/xuzhanhong1/Documents/image-20181110210741530.png)\n\n   当主线程有空闲时间时会把具体剩余时间给react，具体几毫秒到几十毫秒（当最近的将来没有frame scheduled时）\n\n   ![image-20181110211003501](/Users/xuzhanhong1/Documents/image-20181110211003501.png)\n\n   ​\t这样react可以使用这些剩余时间处理更新并当其他工作需要处理时将时间还给主线程。这样的操作需要跟踪两个时间，next unit of work that it needs to work on 和 主线程给与的剩余时间\n\n   ![image-20181110211302791](/Users/xuzhanhong1/Documents/image-20181110211302791.png)\n\n4. 从current复制HostRoot的数据到workInProgress tree 并添加一个指针指向儿子（List）\n\n   ![image-20181110211949517](/Users/xuzhanhong1/Documents/image-20181110211949517.png)\n\n5. 因为List本身没有更新，所以将List复制到workInProgress tree。并且List有更新队列，所以也会复制update Queue。\n\n   ![image-20181110212258539](/Users/xuzhanhong1/Documents/image-20181110212258539.png)\n\n6. 所以List fiber is going to be returned as the next unit of work![image-20181110212347964](/Users/xuzhanhong1/Documents/image-20181110212347964.png)\n\n7. React 会检查deadline是否到来。因为还有剩余的时间，react会继续处理List![image-20181110212645386](/Users/xuzhanhong1/Documents/image-20181110212645386.png)\n\n8. 因为List有更新队列，所以react会处理这些更新，他会调用updater函数，且传对象的setState以后的某个版本被移除![image-20181110212849733](/Users/xuzhanhong1/Documents/image-20181110212849733.png)并结束处理更新队列，fiber会标记一个tag表示他会修改dom树![image-20181110213110874](/Users/xuzhanhong1/Documents/image-20181110213110874.png)\n\n9. 在继续往下处理前，我们需要知道List的children，所以react会在List实例设置props和state并调用render，我们会得到一个数组的元素。react会遍历这些元素去判断在current tree中是否有可以重用的fiber。如果有，则直接复制\n\n   ![image-20181110213813900](/Users/xuzhanhong1/Documents/image-20181110213813900.png)\n\n   ![image-20181110213944644](/Users/xuzhanhong1/Documents/image-20181110213944644.png)\n\n10. 然后会返回List的第一个child button作为下一个unit of work, 然后react会回到work loop并检查deadline。![image-20181110214543420](/Users/xuzhanhong1/Documents/image-20181110214543420.png)![image-20181110214728829](/Users/xuzhanhong1/Documents/image-20181110214728829.png)\n\n11. 这个时候用户想搞事情，点击放大字体按钮去改变web字体大小![image-20181110214856489](/var/folders/h5/1tnmsg713pldfgpyxh4c41wm0m7_pl/T/abnerworks.Typora/image-20181110214856489.png)\n\n12. 这样会导致给队列中的一些东西添加了一个回调，主线程需要去关心的，但是不是马上因为react仍然有时间继续处理next unit of work -- button。button是我们第一个遇到的没有孩子的元素，所以他不会创建新的工作。所以react可以完成这个单位的工作，这意味着比较新旧元素查看是否有变动，如果有变动需要变动dom则会标记。然后因为button没有孩子，所以会返回邻居作为下一个单位的工作![image-20181110215513582](/Users/xuzhanhong1/Documents/image-20181110215513582.png)\n\n13. react会结束这个单元的工作并回到work loop中检查deadline![image-20181110215657530](/Users/xuzhanhong1/Documents/image-20181110215657530.png)\n\n14. item中有sCU，并且因为sCU返回false所以item1不需要对dom进行修改，所以不需要打标签。然后邻居作为下一个单元的工作。同样地，react回到work loop检查deadline并回来![image-20181110215823086](/Users/xuzhanhong1/Documents/image-20181110215823086.png)\n\n15. 第二个item的sCU返回true，所以会被标记为有更变，然后他的div会被复制过来，并且将div返回作为下一个单元的工作 \n    ![image-20181110220630861](/Users/xuzhanhong1/Documents/image-20181110220630861.png)![image-20181110220704324](/Users/xuzhanhong1/Documents/image-20181110220704324.png)\n\n    \n\n16.  因为我们还有一丢丢时间所以我们准备处理这个div，因为这个div没有children所以我们可以完成它，我们发现这个div的内容变更了，所以我们给他打上标记\n    ![image-20181110222222665](/Users/xuzhanhong1/Documents/image-20181110222423364.png)\n\n17. 因为当前没有邻居也没有children，没有下个单元的工作，所以会调用他父亲的complete，并且这是我们第一次将变动添加到一个列表，因为他有tag且完成了(completed)。\n    ![image-20181110224035848](/Users/xuzhanhong1/Documents/image-20181110224035848.png)\n\n18. 这个时候item也完成了(complated)并且他也有一个tag。so it's going to move itself up to it's going to start creating this list of changes on its parent. It merge its own list of changes into the parents effect list\n\n19. item会将div的变动放到effect list的第一个，然后将自己放到effect list的末尾\n    ![image-20181110224526544](/Users/xuzhanhong1/Documents/image-20181110224526544.png)\n\n20. 第二个item complete 并返回邻居作为下一个单元的工作![image-20181110224637609](/Users/xuzhanhong1/Documents/image-20181110224637609.png)\n\n    返回work loop，react发现deadline已经到了。所以react会释放资源并让主线程处理其他任务\n\n    ![image-20181110224810666](/Users/xuzhanhong1/Documents/image-20181110224810666.png)\n\n    react仍然需要继续完成任务，所以使用rIC让主线程完成工作后继续调用react\n\n    ![image-20181110224939741](/Users/xuzhanhong1/Documents/image-20181110224939741.png)\n\n    然后主线程会去处理等待中的callback，在这个例子中是layout\n\n    ![image-20181110225030973](/Users/xuzhanhong1/Documents/image-20181110225030973.png)\n\n    不过注意到nothing in the content of our react app is changed even though react note says going to need to change two to four 在将来的某个时间，而不是现在。\n\n    \n\n21. main thread 处理完其他事情会继续调用react，最后两个单元工作和第二个item一样\n\n    ![image-20181110225617532](/Users/xuzhanhong1/Documents/image-20181110225617532.png)\n    ![image-20181110225632116](/Users/xuzhanhong1/Documents/image-20181110225632116.png)\n\n即完成了List下面的所有单元工作，所以List可以调用complete，并将自己和孩子的更变放到effect list中，然后HostRoot也完成了\n![image-20181110225715325](/Users/xuzhanhong1/Documents/image-20181110230128716.png)\n![image-20181110225807413](/Users/xuzhanhong1/Documents/image-20181110225807413.png)\n\n\n\n22. react会将work-in-progress tree设成pending commit，这意味着第一个阶段结束了。我们更新了work-in-progress tree和指出了变动列表\n\n\n\n## 阶段2\n\n1. react 会检查deadline判断是否有时间立刻执行commit，如果不够则在rIC后第一时间commit这个pending commit![image-20181110230504330](/Users/xuzhanhong1/Documents/image-20181110230504330.png)\n2. react会遍历effect list并应该更变到dom上，从第一个fiber开始\n\n![image-20181110230821602](/Users/xuzhanhong1/Documents/image-20181110230821602.png)\n![image-20181110230855909](/Users/xuzhanhong1/Documents/image-20181110230855909.png)\n![image-20181110230913246](/Users/xuzhanhong1/Documents/image-20181110230913246.png)\nitem没有任何改变，因为我们不使用ref，不过如果我们在item中有ref will be detached now and then it would be reattached later\n![image-20181110231153619](/Users/xuzhanhong1/Documents/image-20181110231153619.png)\n![image-20181110231121156](/Users/xuzhanhong1/Documents/image-20181110231121156.png)\n现在所有变动都在第一阶段计算完毕并commit到dom树。这意味着work-in-progress tree is actually a more up-to-date version of state of the app than the current tree，所以react需要修复current tree。他会切换指针，所以当前指针指向我们刚构建的work-in-pregress tree\n![image-20181110231429089](/Users/xuzhanhong1/Documents/image-20181110231429089.png)\n![image-20181110231630674](/Users/xuzhanhong1/Documents/image-20181110231630674.png)\n这意味着react可以在work-in-progress tree中重用旧对象，只需要在下次构建中work-in-progress tree复制key value。这叫double buffering，可以在内存分配和gc中节省时间，现在react完成了这次的commit，并执行剩下的lifecycle hooks和更新任何refs并处理error boundaries\n![image-20181110232043775](/Users/xuzhanhong1/Documents/image-20181110232043775.png)\n\n## 优先级\n\n```javascript\n{\n    \"Synchronous\": \"same as stack rec\",\n    \"Task\": \"before next tick\",\n    \"Animation\": \"before next frame\",\n     \"rIC\":{\n        \t\"High\":\"pretty soon\",\n            \"Low\":\"如数据获取，对100or200ms不敏感\",\n\t\t\t\"Offscreen\": \"prep for display/scroll\"\n        }\n}\n```\n\n高优先级的任务会立刻执行，尽管现在已经开始了低优先级的任务\n\n![image-20181110232753533](/Users/xuzhanhong1/Documents/image-20181110232753533.png)\n\n回到之前我们搞事情的地方，如果我们有一个紧急的font resize button\n![image-20181110233032279](/Users/xuzhanhong1/Documents/image-20181110233032279.png)\n\n用户点击后会放置一个callback到主线程处理队列中\n\n\n\n\n\n\n\n## lifecycle hook during the phase\n\n![image-20181111143014786](/Users/xuzhanhong1/Documents/image-20181111143014786.png)\n\n![image-20181111143107194](/Users/xuzhanhong1/Documents/image-20181111143107194.png)\n\n\n\n## starvation\n\nreusing work where it can. So if it had a low priority work that was done and the high priority work didn't touch that part of the tree then they can reuse that work.\n\n![image-20181111143219524](/Users/xuzhanhong1/Documents/image-20181111143219524.png)\n\n\n\n## 相关资料\n\n[effectTag](http://link.zhihu.com/?target=https%3A//github.com/facebook/react/blob/master/packages/shared/ReactSideEffectTags.js)\n\n[react custom rIC](https://github.com/facebook/react/blob/0154a79fedef38a824a837c535bc853013dd4588/packages/react-scheduler/src/ReactScheduler.js#L25-L31)\n\n",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/learning A Cartoon to Fiber.md",
      "fields": {
        "slug": "/learning A Cartoon to Fiber/"
      }
    },
    "d16d8354-6f61-5f1a-ad48-bd02309a1329": {
      "id": "d16d8354-6f61-5f1a-ad48-bd02309a1329",
      "children": [],
      "parent": "af562c41-a48f-5b7c-b2db-cced04ba9be3",
      "internal": {
        "content": "\n# Promise\n\n见识了一道面试题，重温一下Promise。\n\n## 题目\n\n```javascript\nconst timeout = ms => new Promise((resolve, reject) => {\n setTimeout(() => {\n  resolve();\n }, ms);\n});\n\nconst ajax1 = () => timeout(2000).then(() => {\n console.log('1');\n return 1;\n});\n\nconst ajax2 = () => timeout(1000).then(() => {\n console.log('2');\n return 2;\n});\n\nconst ajax3 = () => timeout(2000).then(() => {\n console.log('3');\n return 3;\n});\n\nmergePromise = ajaxArray => {\n  //填这里\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n console.log('done');\n console.log(data); \n});\n\n// 分别输出\n// 1\n// 2\n// 3\n// done\n// [1, 2, 3]\n```\n\n## 分析\n\n​\t乍看题目没什么困难，要实现也可以强行用timeout延迟ajax2的调用。但是题目肯定不是做完就好了，就在想mergePromise能否写成能实现fc，而不是仅仅完成这一题。难点就在于如何解决forEach或者使用reduce后还能保持then的状态\n\n\n\n## 我理解的Promise\n\n> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n> 特点：\n>\n>   一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n 核心是要理解容器与状态改变后就不会再变的状态。所以根据这个特性可以拓展forEach只能同步执行的弱点，通过forEach将ajaxArray拼在一条Promise链中。\n\n\n\n## Promise学习\n\n### 一个简单的延时器\n\n```javascript\nfunction timeout(ms) {\n \treturn new Promise((resolve,reject)=>{\n\tsetTimeout(resolve, ms)\n})   \n}\n```\n\n\n\n### Promise嵌套\n\n```javascript\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\n\n上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n\n\n### Promise.resolve()\n\n有时需要将现有对象转为 Promise 对象，`Promise.resolve`方法就起到这个作用。\n\n`Promise.resolve`等价于下面的写法。\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n\n\n## 答案\n\n构建顺序执行异步任务的基本块是\n\n```javascript\nvar sequence = Promise.resolve();\narray.forEach(function(item) {\nsequence = sequence.then(//deal item)\n});\n```\n\n\n\n```javascript\nmergePromise = ajaxArray => {\n    //起始的promise\n    var sequence = Promise.resolve();\n    // 存放数组中每一个promise的结果\n    let ret = [];\n    //为了实现Promise链的延续，这里必须返回一个promise，而且返回值是ret\n    return new Promise((reslove, reject)=> \n        ajaxArray.forEach(function(func) {\n        \t//这里的forEach是同步执行的\n            sequence = sequence.then(function() {\n                return func()\n            }).then(function(data) {\n                ret.push(data)\n                if(ret.length===ajaxArray.length){\n                    reslove(ret)\n                    }\n                })\n\n            console.log('!!!', sequence)\n        })\n        )\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n console.log('done');\n console.log(data); \n});\n```\n\n\n\n\n\n",
        "type": "MarkdownRemark",
        "contentDigest": "68d754e187713fdab7c50470da0cb80a",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "Promise",
        "date": "2018-07-25",
        "spoiler": "见识了一道面试题，重温一下Promise。",
        "_PARENT": "af562c41-a48f-5b7c-b2db-cced04ba9be3"
      },
      "excerpt": "",
      "rawMarkdownBody": "\n# Promise\n\n见识了一道面试题，重温一下Promise。\n\n## 题目\n\n```javascript\nconst timeout = ms => new Promise((resolve, reject) => {\n setTimeout(() => {\n  resolve();\n }, ms);\n});\n\nconst ajax1 = () => timeout(2000).then(() => {\n console.log('1');\n return 1;\n});\n\nconst ajax2 = () => timeout(1000).then(() => {\n console.log('2');\n return 2;\n});\n\nconst ajax3 = () => timeout(2000).then(() => {\n console.log('3');\n return 3;\n});\n\nmergePromise = ajaxArray => {\n  //填这里\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n console.log('done');\n console.log(data); \n});\n\n// 分别输出\n// 1\n// 2\n// 3\n// done\n// [1, 2, 3]\n```\n\n## 分析\n\n​\t乍看题目没什么困难，要实现也可以强行用timeout延迟ajax2的调用。但是题目肯定不是做完就好了，就在想mergePromise能否写成能实现fc，而不是仅仅完成这一题。难点就在于如何解决forEach或者使用reduce后还能保持then的状态\n\n\n\n## 我理解的Promise\n\n> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n> 特点：\n>\n>   一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n 核心是要理解容器与状态改变后就不会再变的状态。所以根据这个特性可以拓展forEach只能同步执行的弱点，通过forEach将ajaxArray拼在一条Promise链中。\n\n\n\n## Promise学习\n\n### 一个简单的延时器\n\n```javascript\nfunction timeout(ms) {\n \treturn new Promise((resolve,reject)=>{\n\tsetTimeout(resolve, ms)\n})   \n}\n```\n\n\n\n### Promise嵌套\n\n```javascript\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\n\n上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n\n\n### Promise.resolve()\n\n有时需要将现有对象转为 Promise 对象，`Promise.resolve`方法就起到这个作用。\n\n`Promise.resolve`等价于下面的写法。\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n\n\n## 答案\n\n构建顺序执行异步任务的基本块是\n\n```javascript\nvar sequence = Promise.resolve();\narray.forEach(function(item) {\nsequence = sequence.then(//deal item)\n});\n```\n\n\n\n```javascript\nmergePromise = ajaxArray => {\n    //起始的promise\n    var sequence = Promise.resolve();\n    // 存放数组中每一个promise的结果\n    let ret = [];\n    //为了实现Promise链的延续，这里必须返回一个promise，而且返回值是ret\n    return new Promise((reslove, reject)=> \n        ajaxArray.forEach(function(func) {\n        \t//这里的forEach是同步执行的\n            sequence = sequence.then(function() {\n                return func()\n            }).then(function(data) {\n                ret.push(data)\n                if(ret.length===ajaxArray.length){\n                    reslove(ret)\n                    }\n                })\n\n            console.log('!!!', sequence)\n        })\n        )\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n console.log('done');\n console.log(data); \n});\n```\n\n\n\n\n\n",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/Promise.md",
      "fields": {
        "slug": "/Promise/"
      }
    },
    "69a39cc4-eb3d-5a69-b48f-4f997123b699": {
      "id": "69a39cc4-eb3d-5a69-b48f-4f997123b699",
      "children": [
        "5d6aff10-a2ce-5c90-87e2-9613addfdbf8"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "3ddf1f370fdb721a81da9785b133c1ce",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/react 16.7.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/react 16.7.md",
      "relativePath": "react 16.7.md",
      "extension": "md",
      "size": 2343,
      "prettySize": "2.34 kB",
      "modifiedTime": "2018-12-22T06:12:04.096Z",
      "accessTime": "2018-12-22T06:12:04.096Z",
      "changeTime": "2018-12-22T06:12:04.101Z",
      "birthTime": "2018-12-20T12:15:32.063Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "react 16.7.md",
      "ext": ".md",
      "name": "react 16.7",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4194304,
      "ino": 13367599,
      "blocks": 8,
      "atimeMs": 1545459124096.053,
      "mtimeMs": 1545459124096.1064,
      "ctimeMs": 1545459124101.1467,
      "birthtimeMs": 1545308132063.1357,
      "atime": "2018-12-22T06:12:04.096Z",
      "mtime": "2018-12-22T06:12:04.096Z",
      "ctime": "2018-12-22T06:12:04.101Z",
      "birthtime": "2018-12-20T12:15:32.063Z"
    },
    "5d6aff10-a2ce-5c90-87e2-9613addfdbf8": {
      "id": "5d6aff10-a2ce-5c90-87e2-9613addfdbf8",
      "children": [],
      "parent": "69a39cc4-eb3d-5a69-b48f-4f997123b699",
      "internal": {
        "content": "# react 16.7\n\n## React DOM\n\n### 1. Fix performance of `React.lazy` for large numbers of lazily-loaded components. ([@acdlite](https://github.com/acdlite) in [#14429](https://github.com/facebook/react/pull/14429)) \n\n### 2. Clear fields on unmount to avoid memory leaks. ([@trueadm](https://github.com/trueadm) in [#14276](https://github.com/facebook/react/pull/14276)) \n\n### 3. Fix bug with SSR and context when mixing `react-dom/server@16.6` and `react@<16.6`. ([@gaearon](https://github.com/gaearon) in [#14291](https://github.com/facebook/react/pull/14291)) \n\n### 4. Fix a performance regression in profiling mode. ([@bvaughn](https://github.com/bvaughn) in [#14383](https://github.com/facebook/react/pull/14383))\n\n\n\n## Scheduler\n\n### 1. Post to MessageChannel instead of window. ([@acdlite](https://github.com/acdlite) in [#14234](https://github.com/facebook/react/pull/14234))\n\n​\tScheduler需要在paint之后触发一个task（会用window去postMessage），在队列为空之前每一帧都会发生都会触发。这会导致其他message event handler每一帧都会被调用，即使它们立即退出，这也会增加每帧的显着开销。所以改用MessageChannel\n\n```javascript\n if (typeof MessageChannel === 'function') {\n    // Use a MessageChannel, if support exists\n    var channel = new MessageChannel();\n    channel.port1.onmessage = idleTick;\n    port = channel.port2;\n  } \n```\n\n### 2. Reduce serialization overhead. ([@developit](https://github.com/developit) in [#14249](https://github.com/facebook/react/pull/14249))\n\n在切换到MessageChannel的过程中，还是传递了\"*\"。 这实际上最终会触发序列化。 为了节省一些性能，改用undefined，因为传递一个像0这样的数字仍然会产生序列化开销 \n\n具体可以看*https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_value.h?type=cs&g=0&l=74* \n\n```\n    -  port.postMessage('*');\n    +  port.postMessage(undefined);\n```\n\n### 3. Fix fallback to `setTimeout` in testing environments. ([@bvaughn](https://github.com/bvaughn) in [#14358](https://github.com/facebook/react/pull/14358))\n\n### 4. Add methods for debugging. ([@mrkev](https://github.com/mrkev) in [#14053](https://github.com/facebook/react/pull/14053))\n",
        "type": "MarkdownRemark",
        "contentDigest": "450065926f01d2a06769136f5c582d98",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "react 16.7",
        "date": "2018-12-20",
        "spoiler": "是的，hooks还没来",
        "_PARENT": "69a39cc4-eb3d-5a69-b48f-4f997123b699"
      },
      "excerpt": "",
      "rawMarkdownBody": "# react 16.7\n\n## React DOM\n\n### 1. Fix performance of `React.lazy` for large numbers of lazily-loaded components. ([@acdlite](https://github.com/acdlite) in [#14429](https://github.com/facebook/react/pull/14429)) \n\n### 2. Clear fields on unmount to avoid memory leaks. ([@trueadm](https://github.com/trueadm) in [#14276](https://github.com/facebook/react/pull/14276)) \n\n### 3. Fix bug with SSR and context when mixing `react-dom/server@16.6` and `react@<16.6`. ([@gaearon](https://github.com/gaearon) in [#14291](https://github.com/facebook/react/pull/14291)) \n\n### 4. Fix a performance regression in profiling mode. ([@bvaughn](https://github.com/bvaughn) in [#14383](https://github.com/facebook/react/pull/14383))\n\n\n\n## Scheduler\n\n### 1. Post to MessageChannel instead of window. ([@acdlite](https://github.com/acdlite) in [#14234](https://github.com/facebook/react/pull/14234))\n\n​\tScheduler需要在paint之后触发一个task（会用window去postMessage），在队列为空之前每一帧都会发生都会触发。这会导致其他message event handler每一帧都会被调用，即使它们立即退出，这也会增加每帧的显着开销。所以改用MessageChannel\n\n```javascript\n if (typeof MessageChannel === 'function') {\n    // Use a MessageChannel, if support exists\n    var channel = new MessageChannel();\n    channel.port1.onmessage = idleTick;\n    port = channel.port2;\n  } \n```\n\n### 2. Reduce serialization overhead. ([@developit](https://github.com/developit) in [#14249](https://github.com/facebook/react/pull/14249))\n\n在切换到MessageChannel的过程中，还是传递了\"*\"。 这实际上最终会触发序列化。 为了节省一些性能，改用undefined，因为传递一个像0这样的数字仍然会产生序列化开销 \n\n具体可以看*https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_value.h?type=cs&g=0&l=74* \n\n```\n    -  port.postMessage('*');\n    +  port.postMessage(undefined);\n```\n\n### 3. Fix fallback to `setTimeout` in testing environments. ([@bvaughn](https://github.com/bvaughn) in [#14358](https://github.com/facebook/react/pull/14358))\n\n### 4. Add methods for debugging. ([@mrkev](https://github.com/mrkev) in [#14053](https://github.com/facebook/react/pull/14053))\n",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/react 16.7.md",
      "fields": {
        "slug": "/react 16.7/"
      }
    },
    "9238919a-ba8b-5c13-9887-625986ceb5cd": {
      "id": "9238919a-ba8b-5c13-9887-625986ceb5cd",
      "children": [
        "47075887-16be-50c6-96fc-5d6e79e00345"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "ae828de430c1c809ba2283def2c818e7",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/All about generator.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/All about generator.md",
      "relativePath": "All about generator.md",
      "extension": "md",
      "size": 711,
      "prettySize": "711 B",
      "modifiedTime": "2019-01-23T04:07:33.752Z",
      "accessTime": "2019-01-23T04:07:54.434Z",
      "changeTime": "2019-01-23T04:07:33.752Z",
      "birthTime": "2019-01-23T04:00:06.159Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "All about generator.md",
      "ext": ".md",
      "name": "All about generator",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4096,
      "ino": 16521695,
      "blocks": 8,
      "atimeMs": 1548216474434.2676,
      "mtimeMs": 1548216453751.6328,
      "ctimeMs": 1548216453751.6328,
      "birthtimeMs": 1548216006158.727,
      "atime": "2019-01-23T04:07:54.434Z",
      "mtime": "2019-01-23T04:07:33.752Z",
      "ctime": "2019-01-23T04:07:33.752Z",
      "birthtime": "2019-01-23T04:00:06.159Z"
    },
    "6e86617b-839e-59fd-8c05-7626d88030f6": {
      "id": "6e86617b-839e-59fd-8c05-7626d88030f6",
      "children": [
        "ea8cfa21-a625-585a-a4a0-f7228c379019"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "e30da9cf8c99e3c9deb0834b12a8a2e6",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/state & props update.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/state & props update.md",
      "relativePath": "state & props update.md",
      "extension": "md",
      "size": 19397,
      "prettySize": "19.4 kB",
      "modifiedTime": "2019-01-07T12:30:47.120Z",
      "accessTime": "2019-03-16T11:02:06.161Z",
      "changeTime": "2019-03-15T12:42:48.523Z",
      "birthTime": "2019-01-07T12:24:27.053Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "state & props update.md",
      "ext": ".md",
      "name": "state & props update",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4096,
      "ino": 13873695,
      "blocks": 40,
      "atimeMs": 1552734126161.0461,
      "mtimeMs": 1546864247119.671,
      "ctimeMs": 1552653768522.5063,
      "birthtimeMs": 1546863867053.2976,
      "atime": "2019-03-16T11:02:06.161Z",
      "mtime": "2019-01-07T12:30:47.120Z",
      "ctime": "2019-03-15T12:42:48.523Z",
      "birthtime": "2019-01-07T12:24:27.053Z"
    },
    "41032e46-9ace-53d7-9bab-5db5c57c861e": {
      "id": "41032e46-9ace-53d7-9bab-5db5c57c861e",
      "children": [
        "1b09d9a5-bd3d-5b54-a015-38a243a0175e"
      ],
      "parent": "___SOURCE___",
      "internal": {
        "contentDigest": "cd2a76d339a8f5b6764a03ed19a6b6e4",
        "type": "File",
        "mediaType": "text/markdown",
        "description": "File \"src/pages/why hooks.md\"",
        "owner": "gatsby-source-filesystem"
      },
      "sourceInstanceName": "pages",
      "absolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/why hooks.md",
      "relativePath": "why hooks.md",
      "extension": "md",
      "size": 12301,
      "prettySize": "12.3 kB",
      "modifiedTime": "2019-03-18T06:44:10.288Z",
      "accessTime": "2019-03-18T06:49:08.178Z",
      "changeTime": "2019-03-18T06:44:10.288Z",
      "birthTime": "2019-03-18T02:36:09.515Z",
      "root": "/",
      "dir": "/Users/xuzhanhong1/study/overreacted.io/src/pages",
      "base": "why hooks.md",
      "ext": ".md",
      "name": "why hooks",
      "relativeDirectory": "",
      "dev": 16777220,
      "mode": 33188,
      "nlink": 1,
      "uid": 21211859,
      "gid": 1603212982,
      "rdev": 0,
      "blksize": 4096,
      "ino": 21542618,
      "blocks": 32,
      "atimeMs": 1552891748178.421,
      "mtimeMs": 1552891450287.5427,
      "ctimeMs": 1552891450287.5427,
      "birthtimeMs": 1552876569514.5745,
      "atime": "2019-03-18T06:49:08.178Z",
      "mtime": "2019-03-18T06:44:10.288Z",
      "ctime": "2019-03-18T06:44:10.288Z",
      "birthtime": "2019-03-18T02:36:09.515Z"
    },
    "55557a74-de54-5683-bd78-3de2108f3ce8": {
      "id": "55557a74-de54-5683-bd78-3de2108f3ce8",
      "children": [],
      "parent": "86ce4482-5854-58cb-aa03-bcc2906a61ea",
      "internal": {
        "content": "\n[read this](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)\n\n## createFiberFromTypeAndProps\n\n​\t当一个React元素第一次被转换成fiber node时，React使用createFiberFromTypeAndProps。在随后的更新中React会重用fiber node且只更新从当前React元素获取必须的属性。React还会根据key属性在目录中移动结点位置或删除它如果react元素的render方法没有返回值。\n\n>查看[**ChildReconciler**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js#L239)方法得到所有行动和React针对当前的fiber结点类型执行的相应的方法\n\n## current和workInProgress tree\n\n​\t第一次render结束后，React会生成一个fiber tree映射应用的状态和UI，这个tree一般叫`current`。当React准备开始更新时会构建一个`workInProgress `tree，反映将被渲染到屏幕的将来的状态。\n\n​\t所有的fibers上的工作都会在workInProgress tree上执行。当React遍历current tree时，每一个存在的结点都会创建一个alternate node来构成workInProgress tree。当更新完成且所有的相关工作完成时，React准备将alternate tree渲染到屏幕上。一旦workInProgress tree被渲染到屏幕上，他就会变成current tree。\n\n​\t在代码中你会见到很多函数需要current和workInProgress tree：\n\n```javascript\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {...}\n```\n\n​\t每一个fiber结点的alternate属性会是它在另外一颗树上的副本的引用。一个current tree上的结点会指向workInprogress tree上的结点，反之亦然。\n\n## Side-effects && Effects list\n\n​\t每一个fiber结点可以有与之相关的作用，这些被放在effectTag字段中。所以fiber的effects基本定义了实例在更新完后需要处理的[工作](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js)。例如host组件（DOM 元素）会有adding, updating or removing elements。类组件会有更新refs，调用cDM和cDU生命周期。\n\n​\tReact会构建一个有effects的fiber结点的线性列表去快速遍历。遍历线性列表比遍历树快很多，且没必要花费时间在没有副作用的结点上。这个列表是`finishedWork`tree的子集且它在current和workInProgress tree中使用nextEffect属性链接而不是child属性。\n\n​\t例如，我们的更新会导致`c2`插入到DOM中，`d2`和`c1`改变DOM属性，`b2`触发生命周期。effect list会连接他们所以React可以跳过其他结点。\n\n![img](http://pjpqjxkf6.bkt.clouddn.com/1%2AQ0pCNcK1FfCttek32X_l7A.png)\n\n![img](http://pjpqjxkf6.bkt.clouddn.com/1%2AmbeZ1EsfMsLUk-9hOYyozw.png)\n\n可以看得到，React会从children再到parents执行effects。\n\n## Fiber tree的根节点\n\nReact对每一个这些container创建[fiber root](https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js#L31)，你可以这样找到他们\n\n```javascript\nconst fiberRoot = $('#app')._reactRootContainer._internalRoot\n```\n\n fiber root的current属性中是React存放fiber tree的地方。\n\n```javascript\nconst hostRootFiberNode = fiberRoot.current\n```\n\nfiber tree会用[一种特别的类型的fiber结点](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js#L34)开始：`HostRoot`，通过`stateNode`可以从`HostRoot`fiber结点返回FiberRoot\n\n```javascript\nfiberRoot.current.stateNode === fiberRoot; // true\n```\n\n## Fiber node structure\n\n### stateNode\n\n保持fiber对本地状态的联系， 保存对组件的类实例，DOM节点或与fiber节点关联的其他React元素类型的引用。\n\n### type\n\n定义与此fiber节点关联的功能或类，对于class组件，它指向constructor函数，对于DOM元素，它是HTML tag。\n\n### tag\n\n定义[fiber节点的类型](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js)。被用于决定需要在reconciliation中做什么工作。\n\n### updateQueue\n\n状态更新，回调和DOM更新的队列。\n\n### memoizedState\n\nfiber用于创建输出的state。处理更新时，它会反映当前在屏幕上呈现的状态。\n\n### memoizedProps\n\n在上一次render中fiber用于创建输出的props\n\n### pendingProps\n\n已经从react新元素中更新的props并且需要应用于子组件或DOM元素\n\n你可以在[这里](https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js#L78)找到完整的fiber结构\n\n## 主要流程\n\n### render阶段\n\nreconcile通常从`HostRoot`fiber结点，并通过[renderRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1132)方法开始。但是，React会快速跳过已经处理过的fiber节点知道他找到一个未完成工作的结点。 \n\n#### work loop的主要步骤\n\n​\t所有fiber节点 [在work loop中](https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136)被处理，这里是同步部分的work loop实现：\n\n```javascript\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {...}\n}\n```\n\n`nextUnitOfWork`会保留对`workInProgress`tree中需要处理的fiber节点的引用。当React遍历fiber tree时，会用这个变量去知晓这里是否有其他未完成工作的fiber结点。\n\n这里会有四个主要函数用于遍历tree和发起或完成工作：\n\n- [performUnitOfWork](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1056)\n- [beginWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489)\n- [completeUnitOfWork](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L879)\n- [completeWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532)\n\n![img](http://pjpqjxkf6.bkt.clouddn.com/1%2AA3-yF-3Xf47nPamFpRm64w.gif)\n\n[这里是视频](https://vimeo.com/302222454)\n\n```javascript\nfunction performUnitOfWork(workInProgress) {\n    let next = beginWork(workInProgress);\n    if (next === null) {\n        next = completeUnitOfWork(workInProgress);\n    }\n    return next;\n}\n\nfunction beginWork(workInProgress) {\n    console.log('work performed for ' + workInProgress.name);\n    return workInProgress.child;\n```\n\n​\tperformUnitOfWork从workInProgress tree中接收一个fiber节点然后开始调用beginWork工作。beginWork是开始所有需要执行行动的函数，为了示范，我们简单输出fiber的名字去记录工作已经完成。beginWork总是会返回下一个处理循环的孩子或者null，\n\n​\t如果有下一个孩子，他会赋予workLoop中的nextUnitOfWork。如果没有孩子，React知道已经到达分支的结尾所以他可以完成当前节点。一旦节点完成，它需要为兄弟姐妹执行工作并向父母回溯，这部分会在completeUnitOfWork中完成。\n\n```javascript\nfunction completeUnitOfWork(workInProgress) {\n    while (true) {\n        let returnFiber = workInProgress.return;\n        let siblingFiber = workInProgress.sibling;\n\n        nextUnitOfWork = completeWork(workInProgress);\n\n        if (siblingFiber !== null) {\n            // If there is a sibling, return it\n            // to perform work for this sibling\n            return siblingFiber;\n        } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber,\n            // continue the loop to complete the parent.\n            workInProgress = returnFiber;\n            continue;\n        } else {\n            // We've reached the root.\n            return null;\n        }\n    }\n}\n\nfunction completeWork(workInProgress) {\n    console.log('work completed for ' + workInProgress.name);\n    return null;\n}\n```\n\n​\t在completeUnitOfWork中，React只完成上一个兄弟节点的工作，他没有完成父亲节点的工作。只有在完成以子节点开始的所有分支后，才能完成父节点和回溯的工作。\n\n​\t从实现中可以看出，performUnitOfWork和completeUnitOfWork主要用于迭代目的，而主要活动则在beginWork和completeWork函数中进行。 在本系列的以下文章中，我们将了解ClickCounter组件和span节点会发生什么，因为React步入beginWork和completeWork函数。\n\n### commit 阶段\n\n​\t这个阶段从[completeRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L2306)开始， 他是react更新DOM和调用前后生命周期的方法。当react进入commit阶段时，会有两颗树和effects list。第一颗树(current)代表当前的渲染状态。在`render`阶段会有一颗alternate tree被称作`finishedWork`或`workInProgress`表示即将渲染到屏幕上的状态。这个alternate tree通过child和sibling指针相连，与current tree相似。\n\n​\t然后，还有一个effects list--来自`finishedWork`树的节点子集并通过nextEffect指针链接。要记住effect list是执行render函数的结果。渲染的重点是确定需要插入、更新或删除那些节点，以及哪些组件需要调用其生命周期方法。这就是effect list作用。他正是commit阶段迭代的节点集。\n\n> 为了debug，current tree可以通过fiber root的current字段获取。finishedWork tree可以通过current tree中的`HostFiber`节点的alternate字段获取\n\n​\t在commit阶段执行的主要函数是[commitRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)，他的主要流程如下：\n\n- 对有`Snapshot`effect的节点调用`getSnapshotBeforeUpdate`\n- 对有`Deletion`effect的节点调用`cWU`\n- 执行所有的DOM插入更新和删除\n- 把finished tree转为current tree\n- 对有`Placement`effect的节点调用`cDM`\n- 对有`Update`effect的节点调用`cDU`\n\n​\t在调用变动前的`getSnapshotBeforeUpdate`方法之后，react会在一棵树中提交所有side-effects。会分成两个pass，一是执行所有DOM(host)插入，更新，删除和ref卸载。然后react会将`finishedWork` tree分配给`FiberRoot`并将`workInProgress`tree标记为`current`tree。这些会在commit阶段的第一次pass后执行。所以在`cWU`阶段的current还是旧的，但是`cDM/cDU`阶段current就是`finishedWork`tree了。\n\n```javascript\nfunction commitRoot(root, finishedWork) {\n    commitBeforeMutationLifecycles()\n    commitAllHostEffects();\n    root.current = finishedWork;\n    commitAllLifeCycles();\n}\n```\n\n​\t每一个子函数都实现了一个循环去遍历effects list并检查effects的类型，当他找到想要的，就会应用它。\n\n#### 变化前的生命周期\n\n​\t例如，迭代effects list并检查检查节点是否有`Snapshot`effect的代码：\n\n```javascript\n//ReactFiberCommitWork.js\nfunction commitBeforeMutationLifecycles() {\n    while (nextEffect !== null) {\n        const effectTag = nextEffect.effectTag;\n        if (effectTag & Snapshot) {\n            const current = nextEffect.alternate;\n            commitBeforeMutationLifeCycles(current, nextEffect);\n        }\n        nextEffect = nextEffect.nextEffect;\n    }\n}\n```\n\n对于一个class组件，这个effect意味着调用`getSnapshotBeforeUpdate`生命周期函数\n\n#### DOM更新\n\n[commitAllHostEffects](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376)是react执行DOM更新的函数。这个函数定义了需要被执行的类型并解析：\n\n```javascript\nfunction commitAllHostEffects() {\n    switch (primaryEffectTag) {\n        case Placement: {\n            commitPlacement(nextEffect);\n            ...\n        }\n        case PlacementAndUpdate: {\n            commitPlacement(nextEffect);\n            commitWork(current, nextEffect);\n            ...\n        }\n        case Update: {\n            commitWork(current, nextEffect);\n            ...\n        }\n        case Deletion: {\n            commitDeletion(nextEffect);\n            ...\n        }\n    }\n}\n```\n\n有意思的是React是在`commitDeletion`函数中作为删除的一部分调用`cWU`的\n\n#### 变化后的生命周期\n\n[commitAllLifecycles](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L465)是react调用所有剩下的生命周期方法如`cDU`和`cDM`\n\n",
        "type": "MarkdownRemark",
        "contentDigest": "a5f93acd9ae83c423f7a6bede87d6654",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "Inside Fiber",
        "date": "2018-12-22",
        "spoiler": "当我们在讨论Fiber时，我们在讨论什么。",
        "_PARENT": "86ce4482-5854-58cb-aa03-bcc2906a61ea"
      },
      "excerpt": "",
      "rawMarkdownBody": "\n[read this](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)\n\n## createFiberFromTypeAndProps\n\n​\t当一个React元素第一次被转换成fiber node时，React使用createFiberFromTypeAndProps。在随后的更新中React会重用fiber node且只更新从当前React元素获取必须的属性。React还会根据key属性在目录中移动结点位置或删除它如果react元素的render方法没有返回值。\n\n>查看[**ChildReconciler**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js#L239)方法得到所有行动和React针对当前的fiber结点类型执行的相应的方法\n\n## current和workInProgress tree\n\n​\t第一次render结束后，React会生成一个fiber tree映射应用的状态和UI，这个tree一般叫`current`。当React准备开始更新时会构建一个`workInProgress `tree，反映将被渲染到屏幕的将来的状态。\n\n​\t所有的fibers上的工作都会在workInProgress tree上执行。当React遍历current tree时，每一个存在的结点都会创建一个alternate node来构成workInProgress tree。当更新完成且所有的相关工作完成时，React准备将alternate tree渲染到屏幕上。一旦workInProgress tree被渲染到屏幕上，他就会变成current tree。\n\n​\t在代码中你会见到很多函数需要current和workInProgress tree：\n\n```javascript\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {...}\n```\n\n​\t每一个fiber结点的alternate属性会是它在另外一颗树上的副本的引用。一个current tree上的结点会指向workInprogress tree上的结点，反之亦然。\n\n## Side-effects && Effects list\n\n​\t每一个fiber结点可以有与之相关的作用，这些被放在effectTag字段中。所以fiber的effects基本定义了实例在更新完后需要处理的[工作](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js)。例如host组件（DOM 元素）会有adding, updating or removing elements。类组件会有更新refs，调用cDM和cDU生命周期。\n\n​\tReact会构建一个有effects的fiber结点的线性列表去快速遍历。遍历线性列表比遍历树快很多，且没必要花费时间在没有副作用的结点上。这个列表是`finishedWork`tree的子集且它在current和workInProgress tree中使用nextEffect属性链接而不是child属性。\n\n​\t例如，我们的更新会导致`c2`插入到DOM中，`d2`和`c1`改变DOM属性，`b2`触发生命周期。effect list会连接他们所以React可以跳过其他结点。\n\n![img](http://pjpqjxkf6.bkt.clouddn.com/1%2AQ0pCNcK1FfCttek32X_l7A.png)\n\n![img](http://pjpqjxkf6.bkt.clouddn.com/1%2AmbeZ1EsfMsLUk-9hOYyozw.png)\n\n可以看得到，React会从children再到parents执行effects。\n\n## Fiber tree的根节点\n\nReact对每一个这些container创建[fiber root](https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js#L31)，你可以这样找到他们\n\n```javascript\nconst fiberRoot = $('#app')._reactRootContainer._internalRoot\n```\n\n fiber root的current属性中是React存放fiber tree的地方。\n\n```javascript\nconst hostRootFiberNode = fiberRoot.current\n```\n\nfiber tree会用[一种特别的类型的fiber结点](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js#L34)开始：`HostRoot`，通过`stateNode`可以从`HostRoot`fiber结点返回FiberRoot\n\n```javascript\nfiberRoot.current.stateNode === fiberRoot; // true\n```\n\n## Fiber node structure\n\n### stateNode\n\n保持fiber对本地状态的联系， 保存对组件的类实例，DOM节点或与fiber节点关联的其他React元素类型的引用。\n\n### type\n\n定义与此fiber节点关联的功能或类，对于class组件，它指向constructor函数，对于DOM元素，它是HTML tag。\n\n### tag\n\n定义[fiber节点的类型](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js)。被用于决定需要在reconciliation中做什么工作。\n\n### updateQueue\n\n状态更新，回调和DOM更新的队列。\n\n### memoizedState\n\nfiber用于创建输出的state。处理更新时，它会反映当前在屏幕上呈现的状态。\n\n### memoizedProps\n\n在上一次render中fiber用于创建输出的props\n\n### pendingProps\n\n已经从react新元素中更新的props并且需要应用于子组件或DOM元素\n\n你可以在[这里](https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js#L78)找到完整的fiber结构\n\n## 主要流程\n\n### render阶段\n\nreconcile通常从`HostRoot`fiber结点，并通过[renderRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1132)方法开始。但是，React会快速跳过已经处理过的fiber节点知道他找到一个未完成工作的结点。 \n\n#### work loop的主要步骤\n\n​\t所有fiber节点 [在work loop中](https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136)被处理，这里是同步部分的work loop实现：\n\n```javascript\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {...}\n}\n```\n\n`nextUnitOfWork`会保留对`workInProgress`tree中需要处理的fiber节点的引用。当React遍历fiber tree时，会用这个变量去知晓这里是否有其他未完成工作的fiber结点。\n\n这里会有四个主要函数用于遍历tree和发起或完成工作：\n\n- [performUnitOfWork](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1056)\n- [beginWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489)\n- [completeUnitOfWork](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L879)\n- [completeWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532)\n\n![img](http://pjpqjxkf6.bkt.clouddn.com/1%2AA3-yF-3Xf47nPamFpRm64w.gif)\n\n[这里是视频](https://vimeo.com/302222454)\n\n```javascript\nfunction performUnitOfWork(workInProgress) {\n    let next = beginWork(workInProgress);\n    if (next === null) {\n        next = completeUnitOfWork(workInProgress);\n    }\n    return next;\n}\n\nfunction beginWork(workInProgress) {\n    console.log('work performed for ' + workInProgress.name);\n    return workInProgress.child;\n```\n\n​\tperformUnitOfWork从workInProgress tree中接收一个fiber节点然后开始调用beginWork工作。beginWork是开始所有需要执行行动的函数，为了示范，我们简单输出fiber的名字去记录工作已经完成。beginWork总是会返回下一个处理循环的孩子或者null，\n\n​\t如果有下一个孩子，他会赋予workLoop中的nextUnitOfWork。如果没有孩子，React知道已经到达分支的结尾所以他可以完成当前节点。一旦节点完成，它需要为兄弟姐妹执行工作并向父母回溯，这部分会在completeUnitOfWork中完成。\n\n```javascript\nfunction completeUnitOfWork(workInProgress) {\n    while (true) {\n        let returnFiber = workInProgress.return;\n        let siblingFiber = workInProgress.sibling;\n\n        nextUnitOfWork = completeWork(workInProgress);\n\n        if (siblingFiber !== null) {\n            // If there is a sibling, return it\n            // to perform work for this sibling\n            return siblingFiber;\n        } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber,\n            // continue the loop to complete the parent.\n            workInProgress = returnFiber;\n            continue;\n        } else {\n            // We've reached the root.\n            return null;\n        }\n    }\n}\n\nfunction completeWork(workInProgress) {\n    console.log('work completed for ' + workInProgress.name);\n    return null;\n}\n```\n\n​\t在completeUnitOfWork中，React只完成上一个兄弟节点的工作，他没有完成父亲节点的工作。只有在完成以子节点开始的所有分支后，才能完成父节点和回溯的工作。\n\n​\t从实现中可以看出，performUnitOfWork和completeUnitOfWork主要用于迭代目的，而主要活动则在beginWork和completeWork函数中进行。 在本系列的以下文章中，我们将了解ClickCounter组件和span节点会发生什么，因为React步入beginWork和completeWork函数。\n\n### commit 阶段\n\n​\t这个阶段从[completeRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L2306)开始， 他是react更新DOM和调用前后生命周期的方法。当react进入commit阶段时，会有两颗树和effects list。第一颗树(current)代表当前的渲染状态。在`render`阶段会有一颗alternate tree被称作`finishedWork`或`workInProgress`表示即将渲染到屏幕上的状态。这个alternate tree通过child和sibling指针相连，与current tree相似。\n\n​\t然后，还有一个effects list--来自`finishedWork`树的节点子集并通过nextEffect指针链接。要记住effect list是执行render函数的结果。渲染的重点是确定需要插入、更新或删除那些节点，以及哪些组件需要调用其生命周期方法。这就是effect list作用。他正是commit阶段迭代的节点集。\n\n> 为了debug，current tree可以通过fiber root的current字段获取。finishedWork tree可以通过current tree中的`HostFiber`节点的alternate字段获取\n\n​\t在commit阶段执行的主要函数是[commitRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)，他的主要流程如下：\n\n- 对有`Snapshot`effect的节点调用`getSnapshotBeforeUpdate`\n- 对有`Deletion`effect的节点调用`cWU`\n- 执行所有的DOM插入更新和删除\n- 把finished tree转为current tree\n- 对有`Placement`effect的节点调用`cDM`\n- 对有`Update`effect的节点调用`cDU`\n\n​\t在调用变动前的`getSnapshotBeforeUpdate`方法之后，react会在一棵树中提交所有side-effects。会分成两个pass，一是执行所有DOM(host)插入，更新，删除和ref卸载。然后react会将`finishedWork` tree分配给`FiberRoot`并将`workInProgress`tree标记为`current`tree。这些会在commit阶段的第一次pass后执行。所以在`cWU`阶段的current还是旧的，但是`cDM/cDU`阶段current就是`finishedWork`tree了。\n\n```javascript\nfunction commitRoot(root, finishedWork) {\n    commitBeforeMutationLifecycles()\n    commitAllHostEffects();\n    root.current = finishedWork;\n    commitAllLifeCycles();\n}\n```\n\n​\t每一个子函数都实现了一个循环去遍历effects list并检查effects的类型，当他找到想要的，就会应用它。\n\n#### 变化前的生命周期\n\n​\t例如，迭代effects list并检查检查节点是否有`Snapshot`effect的代码：\n\n```javascript\n//ReactFiberCommitWork.js\nfunction commitBeforeMutationLifecycles() {\n    while (nextEffect !== null) {\n        const effectTag = nextEffect.effectTag;\n        if (effectTag & Snapshot) {\n            const current = nextEffect.alternate;\n            commitBeforeMutationLifeCycles(current, nextEffect);\n        }\n        nextEffect = nextEffect.nextEffect;\n    }\n}\n```\n\n对于一个class组件，这个effect意味着调用`getSnapshotBeforeUpdate`生命周期函数\n\n#### DOM更新\n\n[commitAllHostEffects](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376)是react执行DOM更新的函数。这个函数定义了需要被执行的类型并解析：\n\n```javascript\nfunction commitAllHostEffects() {\n    switch (primaryEffectTag) {\n        case Placement: {\n            commitPlacement(nextEffect);\n            ...\n        }\n        case PlacementAndUpdate: {\n            commitPlacement(nextEffect);\n            commitWork(current, nextEffect);\n            ...\n        }\n        case Update: {\n            commitWork(current, nextEffect);\n            ...\n        }\n        case Deletion: {\n            commitDeletion(nextEffect);\n            ...\n        }\n    }\n}\n```\n\n有意思的是React是在`commitDeletion`函数中作为删除的一部分调用`cWU`的\n\n#### 变化后的生命周期\n\n[commitAllLifecycles](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L465)是react调用所有剩下的生命周期方法如`cDU`和`cDM`\n\n",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/Inside Fiber.md",
      "fields": {
        "slug": "/Inside Fiber/"
      }
    },
    "47075887-16be-50c6-96fc-5d6e79e00345": {
      "id": "47075887-16be-50c6-96fc-5d6e79e00345",
      "children": [],
      "parent": "9238919a-ba8b-5c13-9887-625986ceb5cd",
      "internal": {
        "content": "\n## co的基本实现\n\n```javascript\nconst get = (url)=> {\n  return fetch(url).then(function(response) {\n    return response.json();\n  })\n}\n\nfunction* getData(){\n  let data = yield get('https://api.github.com/users/github')\n  console.log(data)\n  return data\n}\n\nconst co = (gen) => {\n  ctx = gen()\n  return new Promise((resolve, reject)=>{\n    const temp = (value)=> {\n      let val = ctx.next(value)\n      console.log('temp', value, val)\n      if(val.done){\n        return resolve(val.value)\n      }\n      val.value.then(data=>temp(data))\n    }\n    temp()\n  })\n}\nco(getData).then(data=> {console.log(\"!!!!\",data) })\n```",
        "type": "MarkdownRemark",
        "contentDigest": "1994cb00b4089fa4dbd825e67f5be746",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "All about generator",
        "date": "2019-01-23",
        "spoiler": "重新学习javaScript异步",
        "_PARENT": "9238919a-ba8b-5c13-9887-625986ceb5cd"
      },
      "excerpt": "",
      "rawMarkdownBody": "\n## co的基本实现\n\n```javascript\nconst get = (url)=> {\n  return fetch(url).then(function(response) {\n    return response.json();\n  })\n}\n\nfunction* getData(){\n  let data = yield get('https://api.github.com/users/github')\n  console.log(data)\n  return data\n}\n\nconst co = (gen) => {\n  ctx = gen()\n  return new Promise((resolve, reject)=>{\n    const temp = (value)=> {\n      let val = ctx.next(value)\n      console.log('temp', value, val)\n      if(val.done){\n        return resolve(val.value)\n      }\n      val.value.then(data=>temp(data))\n    }\n    temp()\n  })\n}\nco(getData).then(data=> {console.log(\"!!!!\",data) })\n```",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/All about generator.md",
      "fields": {
        "slug": "/All about generator/"
      }
    },
    "ea8cfa21-a625-585a-a4a0-f7228c379019": {
      "id": "ea8cfa21-a625-585a-a4a0-f7228c379019",
      "children": [],
      "parent": "6e86617b-839e-59fd-8c05-7626d88030f6",
      "internal": {
        "content": "\nDemo:\n\nhttps://stackblitz.com/edit/react-jwqn64\n\n```jsx\nclass ClickCounter extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {count: 0};\n        this.handleClick = this.handleClick.bind(this);\n    }\n\n    handleClick() {\n        this.setState((state) => {\n            return {count: state.count + 1};\n        });\n    }\n    \n    componentDidUpdate() {}\n\n    render() {\n        return [\n            <button key=\"1\" onClick={this.handleClick}>Update counter</button>,\n            <span key=\"2\">{this.state.count}</span>\n        ]\n    }\n}\n```\n\n当我们点击button时，我们可以看到[**completeWork**](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532)：\n\n* 更新`ClickCounter`中的count state\n* 调用`render`方法去得到children列表并执行比较\n* 更新`span`元素的props\n\n在[**commitRoot**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)：\n\n* 更新`span`元素的`textContent`属性\n* 调用`cDU`\n\n## render阶段\n\n### Scheduling updates（安排更新）\n\n​\t当我们点击按钮，会触发点击事件然后react解析我们传给按钮props的callback。在这个应用中callback是增加counter并更新state。\n\n```jsx\nclass ClickCounter extends React.Component {\n    //...\n    handleClick() {\n        this.setState((state) => {\n            return {count: state.count + 1};\n        });\n    }\n}   \n```\n\n​\t\t每一个React组件都有一个`updater`作为组件和react核心通信的桥梁。他允许`setState`在不同的环境下（ReactDOM，RN， SSR， test）实现不同的效果\n\n> 注：关于updater，可以关联学习dan大神博客的[How Does setState Know What to Do?]( https://overreacted.io/how-does-setstate-know-what-to-do/) \n\n​\t在这篇文章中，我们会侧重ReactDom的使用了Fiber reconciler的updater实现，对于`ClickCounter`组件是[**classComponentUpdater**](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js#L186)，他负责检索fiber实例，队列更新和安排工作。\n\n​\t当更新排队时，他们基本上只是被添加到fiber节点上处理的更新队列中。在我们的实例中，与ClickCounter组件对应的fiber节点有以下的结构\n\n```javascript\n{\n    stateNode: new ClickCounter,\n    type: ClickCounter,\n    updateQueue: {\n         baseState: {count: 0}\n         firstUpdate: {\n             next: {\n                 payload: (state) => { return {count: state.count + 1} }\n             }\n         },\n         ...\n     },\n     ...\n}\n```\n\n我们可以看到，`updateQueue.firstUpdate.next.payload`中的函数是我们传给`ClickCounter`组件中setState的callback。他表示在render阶段需要被处理的第一个更新。\n\n### 处理ClickCounter Fiber结点的更新\n\n​\t我们已经有一个ClickCounter实例，所以我们进入[**updateClassInstance**](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js#L976)函数，这里是react对class组件执行最多操作的函数。以下是按执行顺序在函数中执行的最重要的操作：\n\n* 调用**UNSAFE_componentWillReceiveProps**钩子（在react v17中弃用）\n* 执行**updateQueue**中的更新并生成新的state\n* 用新的state调用**getDerivedStateFromProps**并得到结果\n* 调用**sCU**确定一个组件是否需要更新，如果**false**，跳过整个渲染过程\n* 调用**UNSAFE_componentWillUpdate**钩子（在react v17中弃用）\n* 添加一个effect去触发**componentDidUpdate**钩子\n\n> **cDU**这个effect在**render**阶段中被添加，但是在**commit**中执行\n\n* 更新组件实例的**state**和**props**\n\n函数简化后如下：\n\n```javascript\nfunction updateClassInstance(current, workInProgress, ctor, newProps, ...) {\n    const instance = workInProgress.stateNode;\n\n    const oldProps = workInProgress.memoizedProps;\n    instance.props = oldProps;\n    if (oldProps !== newProps) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, ...);\n    }\n\n    let updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n        processUpdateQueue(workInProgress, updateQueue, ...);\n        newState = workInProgress.memoizedState;\n    }\n\n    applyDerivedStateFromProps(workInProgress, ...);\n    newState = workInProgress.memoizedState;\n\n    const shouldUpdate = checkShouldComponentUpdate(workInProgress, ctor, ...);\n    if (shouldUpdate) {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n        workInProgress.effectTag |= Update;\n        workInProgress.effectTag |= Snapshot;\n    }\n\n    instance.props = newProps;\n    instance.state = newState;\n\n    return shouldUpdate;\n}\n```\n\n上面的代码片段移除了一些辅助代码。例如，在调用生命周期方法或添加effect来触发它们时，react会用**typeof**检查一个组件是否实现了这些方法。下面是react在添加effect前检查**cDU**方法\n\n```javascript\nif (typeof instance.componentDidUpdate === 'function') {\n    workInProgress.effectTag |= Update;\n}\n```\n\n好的，现在我们知道在render阶段**ClickCounter**会执行什么操作，现在让我们看看这些操作是怎么改变fiber节点的值。当react开始工作前，**ClickCounter**的fiber节点：\n\n```javascript\n{\n    effectTag: 0,\n    elementType: class ClickCounter,\n    firstEffect: null,\n    memoizedState: {count: 0},\n    type: class ClickCounter,\n    stateNode: {\n        state: {count: 0}\n    },\n    updateQueue: {\n        baseState: {count: 0},\n        firstUpdate: {\n            next: {\n                payload: (state, props) => {…}\n            }\n        },\n        ...\n    }\n}\n```\n\n在工作完成后，fiber节点是这样的：\n\n```javascript\n{\n    effectTag: 4,\n    elementType: class ClickCounter,\n    firstEffect: null,\n    memoizedState: {count: 1},\n    type: class ClickCounter,\n    stateNode: {\n        state: {count: 1}\n    },\n    updateQueue: {\n        baseState: {count: 1},\n        firstUpdate: null,\n        ...\n    }\n}\n```\n\n在更新被执行后，**count**的值在**memoized**和**updateQueue**中的**baseState**变成了**1**。react也更新了**ClickCounter**组件实例中的state(stateNode)。\n\n在这个时候，队列中已经没有更新了，所以**firstUpdate**是**null**。而且**effectTag**从0->4，二进制中是100，即第三位设了1，意义是 [side-effect tag](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js)中的**Update**:\n\n```javascript\nexport const Update = 0b00000000100;\n```\n\n总结，当在处理ClickCounter fiber节点时，react调用更新前的生命周期，更新state和定义相应的side-effects。\n\n### Reconciling children for the ClickCounter Fiber\n\n下一步，react开始 [finishClassComponent](https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/react-reconciler/src/ReactFiberBeginWork.js#L355)，在这里react会调用react组件实例的**render**方法并在组件返回的的孩子上应用diff算法。更高阶的概述在这个[文档](https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm)。\n\n> 当比较两个相同类型的React DOM元素时，React查看两者的属性，保持相同的底层DOM节点，并仅更新更改的属性。\n\n如果我们深入挖掘，我们会发现实际上是比较react元素的fiber节点，但我现在不会详细介绍，因为这个过程非常精细。我会写一篇单独的文章，特别关注child reconciliation。\n\n> 如果您急于自己学习细节，查看[reconcileChildrenArray](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js#L732)函数因为我们这个应用的render方法返回了一个react元素的数组。\n\n我们需要理解两个重要的概念：\n\n1. 当react执行child reconciliation时，他创建或更新render方法返回的reac元素的fiber节点。**finishClassComponent**函数返回当前fiber节点第一个孩子的引用。它会分配到**nextUnitOfWork**并在稍后的work loop中处理。\n\n2. react更新children的props作为parent工作的一部分。为此，它使用来自render方法返回的React元素的数据。例如，这是**span**在react reconcile之前的fiber节点\n\n   ```javascript\n   {\n       stateNode: new HTMLSpanElement,\n       type: \"span\",\n       key: \"2\",\n       memoizedProps: {children: 0},\n       pendingProps: {children: 0},\n       ...\n   }\n   ```\n\n   可以看到，**memoizedProps**和**pendingProps**中的**children**是**0**，这里是span元素被render后返回的react元素\n\n   ```javascript\n   {\n       $$typeof: Symbol(react.element)\n       key: \"2\"\n       props: {children: 1}\n       ref: null\n       type: \"span\"\n   }\n   ```\n\n   可以看到，fiber节点中的props和被返回的react元素有不同，在[**createWorkInProgress**](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L326)函数中创建alternate fiber节点，**react会从react元素中有更新的属性中复制到fiber节点**。所以，当react结束**ClickCouter**组件的child reconciliation，**span**的fiber节点会更新**pendingProps**属性。\n\n   ```javascript\n   {\n       stateNode: new HTMLSpanElement,\n       type: \"span\",\n       key: \"2\",\n       memoizedProps: {children: 0},\n       pendingProps: {children: 1},\n       ...\n   }\n   ```\n\n   当react执行span fiber节点工作时，会将pendingProps复制到**memoizedProps**中并添加一个effects去更新DOM。\n\n   \n\n   这就是render阶段react在**ClickCounter** fiber节点上的工作。因为button是ClickCounter组件的第一个孩子，他会被分配到**nextUnitOfWork**，且他没什么卵事要干，所以react会移动到他的兄弟节点--span。\n\n\n\n\n\n### Processing updates for the Span fiber\n\n与**ClickCounter**相似，从[beginWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489)函数开始。因为**span**节点是**HostComponent**类型，所以：\n\n````javascript\nfunction beginWork(current$$1, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        case FunctionalComponent: {...}\n        case ClassComponent: {...}\n        case HostComponent:\n          return updateHostComponent(current, workInProgress, ...);\n        case ...\n}\n````\n\n在[updateHostComponent](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L686)结束。可以与class组件调用的**updateClassComponent**对比。对于函数式组件是**updateFunctionComponent**。你可以在[**ReactFiberBeginWork.js**](https://github.com/facebook/react/blob/1034e26fe5e42ba07492a736da7bdf5bf2108bc6/packages/react-reconciler/src/ReactFiberBeginWork.js)中找到所有这些函数。\n\n### Reconciling children for the span fiber\n\n在我们的例子中，span节点的**updateHostComponent**中没有特别重要的事情发生。\n\n### Completing work for the Span Fiber node\n\n当**beginWork**结束后，会进入**completeWork**。不过在这之前，react需要更新span fiber节点上的**memoizedProps**，你可能还记得当**ClickCounter**上reconciling children时，react更新了span fiber节点的**pendingProps**\n\n```javascript\n//这是之前的\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    key: \"2\",\n    memoizedProps: {children: 0},\n    pendingProps: {children: 1},\n    ...\n}\n```\n\n当**span**的fiber**beginWork**完成后，react更新pendingProps以匹配memoizedProps\n\n```javascript\nfunction performUnitOfWork(workInProgress) {\n    ...\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n    workInProgress.memoizedProps = workInProgress.pendingProps;\n    ...\n}\n```\n\n然后它调用completeWork函数，它基本上是一个类似于我们在beginWork中看到的大转换语句\n\n```javascript\n\nfunction completeWork(current, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        case FunctionComponent: {...}\n        case ClassComponent: {...}\n        case HostComponent: {\n            ...\n            updateHostComponent(current, workInProgress, ...);\n        }\n        case ...\n    }\n}\n```\n\n由于我们的span Fiber节点是HostComponent，因此它运行[**updateHostComponent**](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L686)函数。在这个函数中，React基本上执行以下操作：\n\n* 准备DOM更新\n* 将这些更新放到span fiber节点的updateQueue\n* 将这些effect应用到更新DOM上\n\n在执行这些操作之前，span Fiber节点如下所示：\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    effectTag: 0\n    updateQueue: null\n    ...\n}\n```\n\n当工作完成时，它看起来像这样：\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    effectTag: 4,\n    updateQueue: [\"children\", \"1\"],\n    ...\n}\n```\n\n​\t注意effectTag和updateQueue字段的区别。它不再是0，它的值是4.在二进制中，这是100，这意味着第三位被设置，这是**update** side-effect的标志位。这是react需要在接下来的commit阶段对这个节点仅需的工作。**updateQueue**字段保存将用于更新的有效payload。 \n\n​\t当react处理完**ClickCounter**和他的孩子，render阶段就结束了。它现在可以将完成的alternate tree分配给FiberRoot上的finishedWork属性。这是需要刷新到屏幕的新树。它可以在渲染阶段后立即处理，也可以在浏览器给出React时间后再处理。\n\n### Effects list\n\n​\t在我们的例子中，因为span节点和ClickCounter组件有side effects，react会将span的fiber节点连接到HostFiber的firstEffect属性。react会在[**compliteUnitOfWork**](https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js#L999)函数构建effects list，以下是具有更新span节点和ClickCounter上的钩子效果的fiber tree：\n\n![](http://pjpqjxkf6.bkt.clouddn.com/1_TRmFSeuOuWlY3HXh86cvDA.png)\n\n## commit阶段\n\n​\tcommit阶段是react更新DOM和调用cDU生命周期。为了实现，react会遍历render阶段构建的effects list并应用他们。\n\n```javascript\n{ type: ClickCounter, effectTag: 5 }\n{ type: 'span', effectTag: 4 }\n```\n\n​\tClickCouter的effect tag是5（二进制是101），定义了**Update**，对于class组件来说基本上是转换**componentDidUpdate**，二进制的最后一位被设置意味着这个fiber节点在**render**阶段的所有工作已经完成。\n\n​\tspan的effect tag是4（二进制100），定义了 update，对于host组件来说是DOM更新。在span元素的情况下，react会更新元素的**textContent**。\n\n### Applying effects\n\n​\t让我们看看react是如何应用这些effects的，[**commitRoot**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)函数，包含了三个子函数：\n\n```javascript\nfunction commitRoot(root, finishedWork) {\n    commitBeforeMutationLifecycles()\n    commitAllHostEffects();\n    root.current = finishedWork;\n    commitAllLifeCycles();\n}\n```\n\n \t每一个子函数都会遍历effecys list并检查effects的类型。当它找到与函数目的相关的效果时，它会应用它。在我们的例子中，commitRoot会调用**ClickCounter**的**cDU**和更新**span**元素的文本。\n\n​\t第一个函数[commitBeforeMutationLifeCycles](https://github.com/facebook/react/blob/fefa1269e2a67fa5ef0992d5cc1d6114b7948b7e/packages/react-reconciler/src/ReactFiberCommitWork.js#L183)会查找[**Snapshot**](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js#L25) effect并调用**getSnapshotBeforeUpdate**方法。不过我们的**ClickCouter**组件没有实现这个方法，react不会在**render**阶段中添加这个effect，所以在我们的例子中，这个函数不起作用。\n\n### DOM updates\n\n​\t下一步，react会执行[**commitAllHostEffects**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376)函数，在这个函数中React会将**span**元素的文本从0改变到1，而ClickCounter组件则不受任何影响因为class组件对应的节点没有任何DOM更新。\n\n​\t该函数的要点是它选择正确的效果类型并应用相应的操作。在我们的例子中，我们需要更新span元素的文本，所以我们在这里采用**Update**分支：\n\n```javascript\nfunction updateHostEffects() {\n    switch (primaryEffectTag) {\n      case Placement: {...}\n      case PlacementAndUpdate: {...}\n      case Update:\n        {\n          var current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n      case Deletion: {...}\n    }\n}\n```\n\n\n\n​\t继续执行**commitWork**，react会执行[**updateDOMProperties**](https://github.com/facebook/react/blob/8a8d973d3cc5623676a84f87af66ef9259c3937c/packages/react-dom/src/client/ReactDOMComponent.js#L326)函数，他将在render阶段添加的updateQueue应用到fiber节点上，并更新**span**元素的**textContent**属性。\n\n```javascript\nfunction updateDOMProperties(domElement, updatePayload, ...) {\n  for (let i = 0; i < updatePayload.length; i += 2) {\n    const propKey = updatePayload[i];\n    const propValue = updatePayload[i + 1];\n    if (propKey === STYLE) { ...} \n    else if (propKey === DANGEROUSLY_SET_INNER_HTML) {...} \n    else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {...}\n  }\n}\n```\n\n​\t当DOM更新被执行后，react将**finishedWork**树分配到**HostRoot**：\n\n```javascript\nroot.current = finishedWork;\n```\n\n\n\n### Calling post mutation lifecycle hooks\n\n​\t剩下的最后一个函数是[**commitAllLifecycles**](https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js#L479)。在这里react会调用更新后的生命周期。在render阶段中，react添加**Update** effect到**ClickCounter**组件中。这是**commitAllLifecycles**查找并调用的其中一个周期。\n\n```javascript\nfunction commitAllLifeCycles(finishedRoot, ...) {\n    while (nextEffect !== null) {\n        const effectTag = nextEffect.effectTag;\n\n        if (effectTag & (Update | Callback)) {\n            const current = nextEffect.alternate;\n            commitLifeCycles(finishedRoot, current, nextEffect, ...);\n        }\n        \n        if (effectTag & Ref) {\n            commitAttachRef(nextEffect);\n        }\n        \n        nextEffect = nextEffect.nextEffect;\n    }\n}\n```\n\n​\t在这个函数中，react也会调用第一次被渲染的组件的**cDM**",
        "type": "MarkdownRemark",
        "contentDigest": "b3ef6a40033c4bde18b66149acd4dbcd",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "state & props update",
        "date": "2018-01-07",
        "spoiler": "深入react内部",
        "_PARENT": "6e86617b-839e-59fd-8c05-7626d88030f6"
      },
      "excerpt": "",
      "rawMarkdownBody": "\nDemo:\n\nhttps://stackblitz.com/edit/react-jwqn64\n\n```jsx\nclass ClickCounter extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {count: 0};\n        this.handleClick = this.handleClick.bind(this);\n    }\n\n    handleClick() {\n        this.setState((state) => {\n            return {count: state.count + 1};\n        });\n    }\n    \n    componentDidUpdate() {}\n\n    render() {\n        return [\n            <button key=\"1\" onClick={this.handleClick}>Update counter</button>,\n            <span key=\"2\">{this.state.count}</span>\n        ]\n    }\n}\n```\n\n当我们点击button时，我们可以看到[**completeWork**](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532)：\n\n* 更新`ClickCounter`中的count state\n* 调用`render`方法去得到children列表并执行比较\n* 更新`span`元素的props\n\n在[**commitRoot**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)：\n\n* 更新`span`元素的`textContent`属性\n* 调用`cDU`\n\n## render阶段\n\n### Scheduling updates（安排更新）\n\n​\t当我们点击按钮，会触发点击事件然后react解析我们传给按钮props的callback。在这个应用中callback是增加counter并更新state。\n\n```jsx\nclass ClickCounter extends React.Component {\n    //...\n    handleClick() {\n        this.setState((state) => {\n            return {count: state.count + 1};\n        });\n    }\n}   \n```\n\n​\t\t每一个React组件都有一个`updater`作为组件和react核心通信的桥梁。他允许`setState`在不同的环境下（ReactDOM，RN， SSR， test）实现不同的效果\n\n> 注：关于updater，可以关联学习dan大神博客的[How Does setState Know What to Do?]( https://overreacted.io/how-does-setstate-know-what-to-do/) \n\n​\t在这篇文章中，我们会侧重ReactDom的使用了Fiber reconciler的updater实现，对于`ClickCounter`组件是[**classComponentUpdater**](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js#L186)，他负责检索fiber实例，队列更新和安排工作。\n\n​\t当更新排队时，他们基本上只是被添加到fiber节点上处理的更新队列中。在我们的实例中，与ClickCounter组件对应的fiber节点有以下的结构\n\n```javascript\n{\n    stateNode: new ClickCounter,\n    type: ClickCounter,\n    updateQueue: {\n         baseState: {count: 0}\n         firstUpdate: {\n             next: {\n                 payload: (state) => { return {count: state.count + 1} }\n             }\n         },\n         ...\n     },\n     ...\n}\n```\n\n我们可以看到，`updateQueue.firstUpdate.next.payload`中的函数是我们传给`ClickCounter`组件中setState的callback。他表示在render阶段需要被处理的第一个更新。\n\n### 处理ClickCounter Fiber结点的更新\n\n​\t我们已经有一个ClickCounter实例，所以我们进入[**updateClassInstance**](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js#L976)函数，这里是react对class组件执行最多操作的函数。以下是按执行顺序在函数中执行的最重要的操作：\n\n* 调用**UNSAFE_componentWillReceiveProps**钩子（在react v17中弃用）\n* 执行**updateQueue**中的更新并生成新的state\n* 用新的state调用**getDerivedStateFromProps**并得到结果\n* 调用**sCU**确定一个组件是否需要更新，如果**false**，跳过整个渲染过程\n* 调用**UNSAFE_componentWillUpdate**钩子（在react v17中弃用）\n* 添加一个effect去触发**componentDidUpdate**钩子\n\n> **cDU**这个effect在**render**阶段中被添加，但是在**commit**中执行\n\n* 更新组件实例的**state**和**props**\n\n函数简化后如下：\n\n```javascript\nfunction updateClassInstance(current, workInProgress, ctor, newProps, ...) {\n    const instance = workInProgress.stateNode;\n\n    const oldProps = workInProgress.memoizedProps;\n    instance.props = oldProps;\n    if (oldProps !== newProps) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, ...);\n    }\n\n    let updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n        processUpdateQueue(workInProgress, updateQueue, ...);\n        newState = workInProgress.memoizedState;\n    }\n\n    applyDerivedStateFromProps(workInProgress, ...);\n    newState = workInProgress.memoizedState;\n\n    const shouldUpdate = checkShouldComponentUpdate(workInProgress, ctor, ...);\n    if (shouldUpdate) {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n        workInProgress.effectTag |= Update;\n        workInProgress.effectTag |= Snapshot;\n    }\n\n    instance.props = newProps;\n    instance.state = newState;\n\n    return shouldUpdate;\n}\n```\n\n上面的代码片段移除了一些辅助代码。例如，在调用生命周期方法或添加effect来触发它们时，react会用**typeof**检查一个组件是否实现了这些方法。下面是react在添加effect前检查**cDU**方法\n\n```javascript\nif (typeof instance.componentDidUpdate === 'function') {\n    workInProgress.effectTag |= Update;\n}\n```\n\n好的，现在我们知道在render阶段**ClickCounter**会执行什么操作，现在让我们看看这些操作是怎么改变fiber节点的值。当react开始工作前，**ClickCounter**的fiber节点：\n\n```javascript\n{\n    effectTag: 0,\n    elementType: class ClickCounter,\n    firstEffect: null,\n    memoizedState: {count: 0},\n    type: class ClickCounter,\n    stateNode: {\n        state: {count: 0}\n    },\n    updateQueue: {\n        baseState: {count: 0},\n        firstUpdate: {\n            next: {\n                payload: (state, props) => {…}\n            }\n        },\n        ...\n    }\n}\n```\n\n在工作完成后，fiber节点是这样的：\n\n```javascript\n{\n    effectTag: 4,\n    elementType: class ClickCounter,\n    firstEffect: null,\n    memoizedState: {count: 1},\n    type: class ClickCounter,\n    stateNode: {\n        state: {count: 1}\n    },\n    updateQueue: {\n        baseState: {count: 1},\n        firstUpdate: null,\n        ...\n    }\n}\n```\n\n在更新被执行后，**count**的值在**memoized**和**updateQueue**中的**baseState**变成了**1**。react也更新了**ClickCounter**组件实例中的state(stateNode)。\n\n在这个时候，队列中已经没有更新了，所以**firstUpdate**是**null**。而且**effectTag**从0->4，二进制中是100，即第三位设了1，意义是 [side-effect tag](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js)中的**Update**:\n\n```javascript\nexport const Update = 0b00000000100;\n```\n\n总结，当在处理ClickCounter fiber节点时，react调用更新前的生命周期，更新state和定义相应的side-effects。\n\n### Reconciling children for the ClickCounter Fiber\n\n下一步，react开始 [finishClassComponent](https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/react-reconciler/src/ReactFiberBeginWork.js#L355)，在这里react会调用react组件实例的**render**方法并在组件返回的的孩子上应用diff算法。更高阶的概述在这个[文档](https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm)。\n\n> 当比较两个相同类型的React DOM元素时，React查看两者的属性，保持相同的底层DOM节点，并仅更新更改的属性。\n\n如果我们深入挖掘，我们会发现实际上是比较react元素的fiber节点，但我现在不会详细介绍，因为这个过程非常精细。我会写一篇单独的文章，特别关注child reconciliation。\n\n> 如果您急于自己学习细节，查看[reconcileChildrenArray](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactChildFiber.js#L732)函数因为我们这个应用的render方法返回了一个react元素的数组。\n\n我们需要理解两个重要的概念：\n\n1. 当react执行child reconciliation时，他创建或更新render方法返回的reac元素的fiber节点。**finishClassComponent**函数返回当前fiber节点第一个孩子的引用。它会分配到**nextUnitOfWork**并在稍后的work loop中处理。\n\n2. react更新children的props作为parent工作的一部分。为此，它使用来自render方法返回的React元素的数据。例如，这是**span**在react reconcile之前的fiber节点\n\n   ```javascript\n   {\n       stateNode: new HTMLSpanElement,\n       type: \"span\",\n       key: \"2\",\n       memoizedProps: {children: 0},\n       pendingProps: {children: 0},\n       ...\n   }\n   ```\n\n   可以看到，**memoizedProps**和**pendingProps**中的**children**是**0**，这里是span元素被render后返回的react元素\n\n   ```javascript\n   {\n       $$typeof: Symbol(react.element)\n       key: \"2\"\n       props: {children: 1}\n       ref: null\n       type: \"span\"\n   }\n   ```\n\n   可以看到，fiber节点中的props和被返回的react元素有不同，在[**createWorkInProgress**](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L326)函数中创建alternate fiber节点，**react会从react元素中有更新的属性中复制到fiber节点**。所以，当react结束**ClickCouter**组件的child reconciliation，**span**的fiber节点会更新**pendingProps**属性。\n\n   ```javascript\n   {\n       stateNode: new HTMLSpanElement,\n       type: \"span\",\n       key: \"2\",\n       memoizedProps: {children: 0},\n       pendingProps: {children: 1},\n       ...\n   }\n   ```\n\n   当react执行span fiber节点工作时，会将pendingProps复制到**memoizedProps**中并添加一个effects去更新DOM。\n\n   \n\n   这就是render阶段react在**ClickCounter** fiber节点上的工作。因为button是ClickCounter组件的第一个孩子，他会被分配到**nextUnitOfWork**，且他没什么卵事要干，所以react会移动到他的兄弟节点--span。\n\n\n\n\n\n### Processing updates for the Span fiber\n\n与**ClickCounter**相似，从[beginWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489)函数开始。因为**span**节点是**HostComponent**类型，所以：\n\n````javascript\nfunction beginWork(current$$1, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        case FunctionalComponent: {...}\n        case ClassComponent: {...}\n        case HostComponent:\n          return updateHostComponent(current, workInProgress, ...);\n        case ...\n}\n````\n\n在[updateHostComponent](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L686)结束。可以与class组件调用的**updateClassComponent**对比。对于函数式组件是**updateFunctionComponent**。你可以在[**ReactFiberBeginWork.js**](https://github.com/facebook/react/blob/1034e26fe5e42ba07492a736da7bdf5bf2108bc6/packages/react-reconciler/src/ReactFiberBeginWork.js)中找到所有这些函数。\n\n### Reconciling children for the span fiber\n\n在我们的例子中，span节点的**updateHostComponent**中没有特别重要的事情发生。\n\n### Completing work for the Span Fiber node\n\n当**beginWork**结束后，会进入**completeWork**。不过在这之前，react需要更新span fiber节点上的**memoizedProps**，你可能还记得当**ClickCounter**上reconciling children时，react更新了span fiber节点的**pendingProps**\n\n```javascript\n//这是之前的\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    key: \"2\",\n    memoizedProps: {children: 0},\n    pendingProps: {children: 1},\n    ...\n}\n```\n\n当**span**的fiber**beginWork**完成后，react更新pendingProps以匹配memoizedProps\n\n```javascript\nfunction performUnitOfWork(workInProgress) {\n    ...\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n    workInProgress.memoizedProps = workInProgress.pendingProps;\n    ...\n}\n```\n\n然后它调用completeWork函数，它基本上是一个类似于我们在beginWork中看到的大转换语句\n\n```javascript\n\nfunction completeWork(current, workInProgress, ...) {\n    ...\n    switch (workInProgress.tag) {\n        case FunctionComponent: {...}\n        case ClassComponent: {...}\n        case HostComponent: {\n            ...\n            updateHostComponent(current, workInProgress, ...);\n        }\n        case ...\n    }\n}\n```\n\n由于我们的span Fiber节点是HostComponent，因此它运行[**updateHostComponent**](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L686)函数。在这个函数中，React基本上执行以下操作：\n\n* 准备DOM更新\n* 将这些更新放到span fiber节点的updateQueue\n* 将这些effect应用到更新DOM上\n\n在执行这些操作之前，span Fiber节点如下所示：\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    effectTag: 0\n    updateQueue: null\n    ...\n}\n```\n\n当工作完成时，它看起来像这样：\n\n```javascript\n{\n    stateNode: new HTMLSpanElement,\n    type: \"span\",\n    effectTag: 4,\n    updateQueue: [\"children\", \"1\"],\n    ...\n}\n```\n\n​\t注意effectTag和updateQueue字段的区别。它不再是0，它的值是4.在二进制中，这是100，这意味着第三位被设置，这是**update** side-effect的标志位。这是react需要在接下来的commit阶段对这个节点仅需的工作。**updateQueue**字段保存将用于更新的有效payload。 \n\n​\t当react处理完**ClickCounter**和他的孩子，render阶段就结束了。它现在可以将完成的alternate tree分配给FiberRoot上的finishedWork属性。这是需要刷新到屏幕的新树。它可以在渲染阶段后立即处理，也可以在浏览器给出React时间后再处理。\n\n### Effects list\n\n​\t在我们的例子中，因为span节点和ClickCounter组件有side effects，react会将span的fiber节点连接到HostFiber的firstEffect属性。react会在[**compliteUnitOfWork**](https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js#L999)函数构建effects list，以下是具有更新span节点和ClickCounter上的钩子效果的fiber tree：\n\n![](http://pjpqjxkf6.bkt.clouddn.com/1_TRmFSeuOuWlY3HXh86cvDA.png)\n\n## commit阶段\n\n​\tcommit阶段是react更新DOM和调用cDU生命周期。为了实现，react会遍历render阶段构建的effects list并应用他们。\n\n```javascript\n{ type: ClickCounter, effectTag: 5 }\n{ type: 'span', effectTag: 4 }\n```\n\n​\tClickCouter的effect tag是5（二进制是101），定义了**Update**，对于class组件来说基本上是转换**componentDidUpdate**，二进制的最后一位被设置意味着这个fiber节点在**render**阶段的所有工作已经完成。\n\n​\tspan的effect tag是4（二进制100），定义了 update，对于host组件来说是DOM更新。在span元素的情况下，react会更新元素的**textContent**。\n\n### Applying effects\n\n​\t让我们看看react是如何应用这些effects的，[**commitRoot**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)函数，包含了三个子函数：\n\n```javascript\nfunction commitRoot(root, finishedWork) {\n    commitBeforeMutationLifecycles()\n    commitAllHostEffects();\n    root.current = finishedWork;\n    commitAllLifeCycles();\n}\n```\n\n \t每一个子函数都会遍历effecys list并检查effects的类型。当它找到与函数目的相关的效果时，它会应用它。在我们的例子中，commitRoot会调用**ClickCounter**的**cDU**和更新**span**元素的文本。\n\n​\t第一个函数[commitBeforeMutationLifeCycles](https://github.com/facebook/react/blob/fefa1269e2a67fa5ef0992d5cc1d6114b7948b7e/packages/react-reconciler/src/ReactFiberCommitWork.js#L183)会查找[**Snapshot**](https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js#L25) effect并调用**getSnapshotBeforeUpdate**方法。不过我们的**ClickCouter**组件没有实现这个方法，react不会在**render**阶段中添加这个effect，所以在我们的例子中，这个函数不起作用。\n\n### DOM updates\n\n​\t下一步，react会执行[**commitAllHostEffects**](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376)函数，在这个函数中React会将**span**元素的文本从0改变到1，而ClickCounter组件则不受任何影响因为class组件对应的节点没有任何DOM更新。\n\n​\t该函数的要点是它选择正确的效果类型并应用相应的操作。在我们的例子中，我们需要更新span元素的文本，所以我们在这里采用**Update**分支：\n\n```javascript\nfunction updateHostEffects() {\n    switch (primaryEffectTag) {\n      case Placement: {...}\n      case PlacementAndUpdate: {...}\n      case Update:\n        {\n          var current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n      case Deletion: {...}\n    }\n}\n```\n\n\n\n​\t继续执行**commitWork**，react会执行[**updateDOMProperties**](https://github.com/facebook/react/blob/8a8d973d3cc5623676a84f87af66ef9259c3937c/packages/react-dom/src/client/ReactDOMComponent.js#L326)函数，他将在render阶段添加的updateQueue应用到fiber节点上，并更新**span**元素的**textContent**属性。\n\n```javascript\nfunction updateDOMProperties(domElement, updatePayload, ...) {\n  for (let i = 0; i < updatePayload.length; i += 2) {\n    const propKey = updatePayload[i];\n    const propValue = updatePayload[i + 1];\n    if (propKey === STYLE) { ...} \n    else if (propKey === DANGEROUSLY_SET_INNER_HTML) {...} \n    else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {...}\n  }\n}\n```\n\n​\t当DOM更新被执行后，react将**finishedWork**树分配到**HostRoot**：\n\n```javascript\nroot.current = finishedWork;\n```\n\n\n\n### Calling post mutation lifecycle hooks\n\n​\t剩下的最后一个函数是[**commitAllLifecycles**](https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js#L479)。在这里react会调用更新后的生命周期。在render阶段中，react添加**Update** effect到**ClickCounter**组件中。这是**commitAllLifecycles**查找并调用的其中一个周期。\n\n```javascript\nfunction commitAllLifeCycles(finishedRoot, ...) {\n    while (nextEffect !== null) {\n        const effectTag = nextEffect.effectTag;\n\n        if (effectTag & (Update | Callback)) {\n            const current = nextEffect.alternate;\n            commitLifeCycles(finishedRoot, current, nextEffect, ...);\n        }\n        \n        if (effectTag & Ref) {\n            commitAttachRef(nextEffect);\n        }\n        \n        nextEffect = nextEffect.nextEffect;\n    }\n}\n```\n\n​\t在这个函数中，react也会调用第一次被渲染的组件的**cDM**",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/state & props update.md",
      "fields": {
        "slug": "/state & props update/"
      }
    },
    "1b09d9a5-bd3d-5b54-a015-38a243a0175e": {
      "id": "1b09d9a5-bd3d-5b54-a015-38a243a0175e",
      "children": [],
      "parent": "41032e46-9ace-53d7-9bab-5db5c57c861e",
      "internal": {
        "content": "\n## 前言\n\n​\t简单说下为什么React选择函数式组件，主要是class组件比较冗余、生命周期函数写法不友好，骚写法多，functional组件更符合React编程思想等等等。更具体的可以拜读dan大神的blog:[传送门](https://overreacted.io/how-are-function-components-different-from-classes/)。其中**Function components capture the rendered values**这句十分精辟的道出函数式组件的优势。\n\n​\t但是在16.8之前react的函数式组件十分羸弱，基本只能作用于纯展示组件，主要因为缺少state和生命周期。本人曾经在hooks出来前负责过纯函数式的react项目，所有状态处理都必须在reducer中进行，所有副作用都在saga中执行，可以说是十分艰辛的经历了。在hooks出来后我在公司的一个小中台项目中使用，落地效果不错，代码量显著减少的同时提升了代码的可读性。因为通过custom hooks可以更好地剥离代码结构，不会像以前类组件那样在cDU等生命周期堆了一大堆逻辑，在命令式代码和声明式代码中有一个良性的边界。\n\n## useState在React中是怎么实现的\n\n> Hooks take some getting used to — and especially at the boundary of imperative and declarative code.\n\n​\t如果对hooks不太了解的可以先看看这篇文章:[前情提要](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)，十分简明的介绍了hooks的核心原理，但是我对useEffect，useRef等钩子的实现比较好奇，所以开始啃起了源码，下面我会结合源码介绍useState的原理。useState具体逻辑分成三部分：mountState，dispatch， updateState\n\n### hook的结构\n\n首先的是hooks的结构，hooks是挂载在组件Fiber结点上memoizedState的，关于Fiber结点可以看看我的另一篇：[传送门](https://xuzhanhh.com/Inside%20Fiber/)\n\n```javascript\n//hook的结构\nexport type Hook = {\n  memoizedState: any, //上一次的state\n  baseState: any,  //当前state\n  baseUpdate: Update<any, any> | null,  // update func\n  queue: UpdateQueue<any, any> | null,  //用于缓存多次action\n  next: Hook | null, //链表\n};\n```\n\n### renderWithHooks\n\n在reconciler中处理函数式组件的函数是renderWithHooks，其类型是：\n\n```javascript\nrenderWithHooks(\n  current: Fiber | null, //当前的fiber结点\n  workInProgress: Fiber, \n  Component: any, //jsx中用<>调用的函数\n  props: any,\n  refOrContext: any,\n  nextRenderExpirationTime: ExpirationTime, //需要在什么时候结束\n): any\n```\n\n在renderWithHooks，核心流程如下：\n\n```javascript\n//从memoizedState中取出hooks\nnextCurrentHook = current !== null ? current.memoizedState : null; \n//判断通过有没有hooks判断是mount还是update，两者的函数不同\nReactCurrentDispatcher.current =\n      nextCurrentHook === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n//执行传入的type函数\nlet children = Component(props, refOrContext);\n//执行完函数后的dispatcher变成只能调用context的\nReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\nreturn children;\n```\n\n### useState构建时流程\n\n**mountState**\n\n在HooksDispatcherOnMount中，useState调用的是下面的mountState，作用是创建一个新的hook并使用默认值初始化并绑定其触发器，因为useState底层是useReducer，所以数组第二个值返回的是dispatch。\n\n```typescript\ntype BasicStateAction<S> = (S => S) | S;\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n//如果入参是func则会调用，但是不提供参数，带参数的需要包一层\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n//上一个state和基本(当前)state都初始化\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    eagerReducer: basicStateReducer, // useState使用基础reducer\n    eagerState: (initialState: any),\n  });\n//返回触发器\n  const dispatch: Dispatch<\n    //useState底层是useReducer，所以type是BasicStateAction\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchAction.bind(\n    null,\n    //绑定当前fiber结点和queue\n    ((currentlyRenderingFiber: any): Fiber),\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n```\n\n**mountWorkInProgressHook**\n\n这个函数是mountState时调用的构建hook的方法，在初始化完毕后会连接到当前hook.next（如果有的话）\n\n```javascript\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n    baseState: null,\n    queue: null,\n    baseUpdate: null,\n    next: null,\n  };\n  if (workInProgressHook === null) {\n    // 列表中的第一个hook\n    firstWorkInProgressHook = workInProgressHook = hook;\n  } else {\n    // 添加到列表的末尾\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n```\n\n### dispatch分发函数\n\n​\t在上面我们提到，useState底层是useReducer，所以返回的第二个参数是dispatch函数，其中的设计十分巧妙。\n\n假设我们有以下代码:\n\n```javascript\nconst [data, setData] = React.useState(0)\nsetData('first')\nsetData('second')\nsetData('third')\n```\n\n![image-20190317151730512](/images/image-20190317151730512.png)\n\n在第一次setData后， hooks的结构如上图\n\n![image-20190317152006773](/images/image-20190317152006773.png)\n\n在第二次setData后， hooks的结构如上图\n\n![image-20190317152401946](/images/image-20190317152401946.png)\n\n在第三次setData后， hooks的结构如上图\n\n![image-20190318114449227](/images/image-20190318114449227.png)\n\n在正常情况下，是不会在dispatcher中触发reducer而是将action存入update中在updateState中再执行，但是如果在react没有重渲染需求的前提下是会提前计算state即eagerState。作为性能优化的一环。\n\n```typescript\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  const alternate = fiber.alternate;\n   {\n    flushPassiveEffects();\n\t//获取当前时间并计算可用时间\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update: Update<S, A> = {\n      expirationTime,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n\t//下面的代码就是为了构建queue.last是最新的更新，然后last.next开始是每一次的action\n    // 取出last\n    const last = queue.last;\n    if (last === null) {\n      // 自圆\n      update.next = update;\n    } else {\n      const first = last.next;\n      if (first !== null) {\n        \n        update.next = first;\n      }\n      last.next = update;\n    }\n    queue.last = update;\n\n    if (\n      fiber.expirationTime === NoWork &&\n      (alternate === null || alternate.expirationTime === NoWork)\n    ) {\n      // 当前队列为空，我们可以在进入render阶段前提前计算出下一个状态。如果新的状态和当前状态相同，则可以退出重渲染\n      const lastRenderedReducer = queue.lastRenderedReducer; // 上次更新完后的reducer\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;  // 暂存dispatcher\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          // 计算下次state\n          const eagerState = lastRenderedReducer(currentState, action);\n          // 在update对象中存储预计算的完整状态和reducer，如果在进入render阶段前reducer没有变化那么可以服用eagerState而不用重新再次调用reducer\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // 在后续的时间中，如果这个组件因别的原因被重渲染且在那时reducer更变后，仍有可能重建这次更新\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n    scheduleWork(fiber, expirationTime);\n  }\n}\n```\n\n\n\n### useState更新时流程\n\n**updateReducer**\n\n​\t因为useState底层是useReducer，所以在更新时的流程(即重渲染组件后)是调用updateReducer的。\n\n```typescript\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n```\n\n​\t所以其reducer十分简单\n\n```typescript\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n```\n\n​\t我们先把复杂情况抛开，跑通updateReducer流程\n\n```typescript\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  // 获取当前hook,queue\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  queue.lastRenderedReducer = reducer;\n\n  // action队列的最后一个更新\n  const last = queue.last;\n  // 最后一个更新是基本状态\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState;\n\n  // 找到第一个没处理的更新\n  let first;\n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // 第一次更新时，队列是一个自圆queue.last.next = queue.first。当第一次update提交后，baseUpdate不再为空即可跳出队列\n      last.next = null;\n    }\n    first = baseUpdate.next;\n  } else {\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n    do {\n      const updateExpirationTime = update.expirationTime;\n      if (updateExpirationTime < renderExpirationTime) {\n        // 优先级不足，跳过这次更新，如果这是第一次跳过更新，上一个update/state是newBaseupdate/state\n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        }\n        // 更新优先级\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n        }\n      } else {\n        // 处理更新\n        if (update.eagerReducer === reducer) {\n          // 如果更新被提前处理了且reducer跟当前reducer匹配，可以复用eagerState\n          newState = ((update.eagerState: any): S);\n        } else {\n          // 循环调用reducer\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      prevUpdate = update;\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    }\n\n    // 只有在前后state变了才会标记\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n```\n\n\n\n```javascript\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n```\n\n\n\n## 后记\n\n​\t作为系列的第一篇文章，我选择了最常用的hooks开始，抛开提前计算及与react-reconciler的互动，整个流程是十分清晰易懂的。mount的时候构建钩子，触发dispatch时按序插入update。updateState的时候再按序触发reducer。可以说就是一个简单的redux。但是作为系列的开篇我认为知识量已经达到要求了xd",
        "type": "MarkdownRemark",
        "contentDigest": "92cc848036adebd0a960c2d397dd0ce1",
        "owner": "gatsby-transformer-remark",
        "fieldOwners": {
          "slug": "default-site-plugin"
        }
      },
      "frontmatter": {
        "title": "why hooks（一）",
        "date": "2019-03-17",
        "spoiler": "从hooks切入，深入了解React编程模型",
        "_PARENT": "41032e46-9ace-53d7-9bab-5db5c57c861e"
      },
      "excerpt": "",
      "rawMarkdownBody": "\n## 前言\n\n​\t简单说下为什么React选择函数式组件，主要是class组件比较冗余、生命周期函数写法不友好，骚写法多，functional组件更符合React编程思想等等等。更具体的可以拜读dan大神的blog:[传送门](https://overreacted.io/how-are-function-components-different-from-classes/)。其中**Function components capture the rendered values**这句十分精辟的道出函数式组件的优势。\n\n​\t但是在16.8之前react的函数式组件十分羸弱，基本只能作用于纯展示组件，主要因为缺少state和生命周期。本人曾经在hooks出来前负责过纯函数式的react项目，所有状态处理都必须在reducer中进行，所有副作用都在saga中执行，可以说是十分艰辛的经历了。在hooks出来后我在公司的一个小中台项目中使用，落地效果不错，代码量显著减少的同时提升了代码的可读性。因为通过custom hooks可以更好地剥离代码结构，不会像以前类组件那样在cDU等生命周期堆了一大堆逻辑，在命令式代码和声明式代码中有一个良性的边界。\n\n## useState在React中是怎么实现的\n\n> Hooks take some getting used to — and especially at the boundary of imperative and declarative code.\n\n​\t如果对hooks不太了解的可以先看看这篇文章:[前情提要](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)，十分简明的介绍了hooks的核心原理，但是我对useEffect，useRef等钩子的实现比较好奇，所以开始啃起了源码，下面我会结合源码介绍useState的原理。useState具体逻辑分成三部分：mountState，dispatch， updateState\n\n### hook的结构\n\n首先的是hooks的结构，hooks是挂载在组件Fiber结点上memoizedState的，关于Fiber结点可以看看我的另一篇：[传送门](https://xuzhanhh.com/Inside%20Fiber/)\n\n```javascript\n//hook的结构\nexport type Hook = {\n  memoizedState: any, //上一次的state\n  baseState: any,  //当前state\n  baseUpdate: Update<any, any> | null,  // update func\n  queue: UpdateQueue<any, any> | null,  //用于缓存多次action\n  next: Hook | null, //链表\n};\n```\n\n### renderWithHooks\n\n在reconciler中处理函数式组件的函数是renderWithHooks，其类型是：\n\n```javascript\nrenderWithHooks(\n  current: Fiber | null, //当前的fiber结点\n  workInProgress: Fiber, \n  Component: any, //jsx中用<>调用的函数\n  props: any,\n  refOrContext: any,\n  nextRenderExpirationTime: ExpirationTime, //需要在什么时候结束\n): any\n```\n\n在renderWithHooks，核心流程如下：\n\n```javascript\n//从memoizedState中取出hooks\nnextCurrentHook = current !== null ? current.memoizedState : null; \n//判断通过有没有hooks判断是mount还是update，两者的函数不同\nReactCurrentDispatcher.current =\n      nextCurrentHook === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n//执行传入的type函数\nlet children = Component(props, refOrContext);\n//执行完函数后的dispatcher变成只能调用context的\nReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\nreturn children;\n```\n\n### useState构建时流程\n\n**mountState**\n\n在HooksDispatcherOnMount中，useState调用的是下面的mountState，作用是创建一个新的hook并使用默认值初始化并绑定其触发器，因为useState底层是useReducer，所以数组第二个值返回的是dispatch。\n\n```typescript\ntype BasicStateAction<S> = (S => S) | S;\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n//如果入参是func则会调用，但是不提供参数，带参数的需要包一层\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n//上一个state和基本(当前)state都初始化\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    eagerReducer: basicStateReducer, // useState使用基础reducer\n    eagerState: (initialState: any),\n  });\n//返回触发器\n  const dispatch: Dispatch<\n    //useState底层是useReducer，所以type是BasicStateAction\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchAction.bind(\n    null,\n    //绑定当前fiber结点和queue\n    ((currentlyRenderingFiber: any): Fiber),\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n```\n\n**mountWorkInProgressHook**\n\n这个函数是mountState时调用的构建hook的方法，在初始化完毕后会连接到当前hook.next（如果有的话）\n\n```javascript\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n    baseState: null,\n    queue: null,\n    baseUpdate: null,\n    next: null,\n  };\n  if (workInProgressHook === null) {\n    // 列表中的第一个hook\n    firstWorkInProgressHook = workInProgressHook = hook;\n  } else {\n    // 添加到列表的末尾\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n```\n\n### dispatch分发函数\n\n​\t在上面我们提到，useState底层是useReducer，所以返回的第二个参数是dispatch函数，其中的设计十分巧妙。\n\n假设我们有以下代码:\n\n```javascript\nconst [data, setData] = React.useState(0)\nsetData('first')\nsetData('second')\nsetData('third')\n```\n\n![image-20190317151730512](/images/image-20190317151730512.png)\n\n在第一次setData后， hooks的结构如上图\n\n![image-20190317152006773](/images/image-20190317152006773.png)\n\n在第二次setData后， hooks的结构如上图\n\n![image-20190317152401946](/images/image-20190317152401946.png)\n\n在第三次setData后， hooks的结构如上图\n\n![image-20190318114449227](/images/image-20190318114449227.png)\n\n在正常情况下，是不会在dispatcher中触发reducer而是将action存入update中在updateState中再执行，但是如果在react没有重渲染需求的前提下是会提前计算state即eagerState。作为性能优化的一环。\n\n```typescript\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  const alternate = fiber.alternate;\n   {\n    flushPassiveEffects();\n\t//获取当前时间并计算可用时间\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update: Update<S, A> = {\n      expirationTime,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n\t//下面的代码就是为了构建queue.last是最新的更新，然后last.next开始是每一次的action\n    // 取出last\n    const last = queue.last;\n    if (last === null) {\n      // 自圆\n      update.next = update;\n    } else {\n      const first = last.next;\n      if (first !== null) {\n        \n        update.next = first;\n      }\n      last.next = update;\n    }\n    queue.last = update;\n\n    if (\n      fiber.expirationTime === NoWork &&\n      (alternate === null || alternate.expirationTime === NoWork)\n    ) {\n      // 当前队列为空，我们可以在进入render阶段前提前计算出下一个状态。如果新的状态和当前状态相同，则可以退出重渲染\n      const lastRenderedReducer = queue.lastRenderedReducer; // 上次更新完后的reducer\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;  // 暂存dispatcher\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          // 计算下次state\n          const eagerState = lastRenderedReducer(currentState, action);\n          // 在update对象中存储预计算的完整状态和reducer，如果在进入render阶段前reducer没有变化那么可以服用eagerState而不用重新再次调用reducer\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // 在后续的时间中，如果这个组件因别的原因被重渲染且在那时reducer更变后，仍有可能重建这次更新\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n    scheduleWork(fiber, expirationTime);\n  }\n}\n```\n\n\n\n### useState更新时流程\n\n**updateReducer**\n\n​\t因为useState底层是useReducer，所以在更新时的流程(即重渲染组件后)是调用updateReducer的。\n\n```typescript\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n```\n\n​\t所以其reducer十分简单\n\n```typescript\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n```\n\n​\t我们先把复杂情况抛开，跑通updateReducer流程\n\n```typescript\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  // 获取当前hook,queue\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  queue.lastRenderedReducer = reducer;\n\n  // action队列的最后一个更新\n  const last = queue.last;\n  // 最后一个更新是基本状态\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState;\n\n  // 找到第一个没处理的更新\n  let first;\n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // 第一次更新时，队列是一个自圆queue.last.next = queue.first。当第一次update提交后，baseUpdate不再为空即可跳出队列\n      last.next = null;\n    }\n    first = baseUpdate.next;\n  } else {\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n    do {\n      const updateExpirationTime = update.expirationTime;\n      if (updateExpirationTime < renderExpirationTime) {\n        // 优先级不足，跳过这次更新，如果这是第一次跳过更新，上一个update/state是newBaseupdate/state\n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        }\n        // 更新优先级\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n        }\n      } else {\n        // 处理更新\n        if (update.eagerReducer === reducer) {\n          // 如果更新被提前处理了且reducer跟当前reducer匹配，可以复用eagerState\n          newState = ((update.eagerState: any): S);\n        } else {\n          // 循环调用reducer\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      prevUpdate = update;\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    }\n\n    // 只有在前后state变了才会标记\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n```\n\n\n\n```javascript\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n```\n\n\n\n## 后记\n\n​\t作为系列的第一篇文章，我选择了最常用的hooks开始，抛开提前计算及与react-reconciler的互动，整个流程是十分清晰易懂的。mount的时候构建钩子，触发dispatch时按序插入update。updateState的时候再按序触发reducer。可以说就是一个简单的redux。但是作为系列的开篇我认为知识量已经达到要求了xd",
      "fileAbsolutePath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/why hooks.md",
      "fields": {
        "slug": "/why hooks/"
      }
    },
    "SitePage /why hooks/": {
      "jsonName": "why-hooks-e09",
      "internalComponentName": "ComponentWhyHooks",
      "path": "/why hooks/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/why hooks/",
        "previous": {
          "fields": {
            "slug": "/All about generator/"
          },
          "frontmatter": {
            "title": "All about generator"
          }
        },
        "next": null
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /why hooks/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "c061b4dc9fec21727823efc880430210",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /All about generator/": {
      "jsonName": "all-about-generator-055",
      "internalComponentName": "ComponentAllAboutGenerator",
      "path": "/All about generator/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/All about generator/",
        "previous": {
          "fields": {
            "slug": "/Inside Fiber/"
          },
          "frontmatter": {
            "title": "Inside Fiber"
          }
        },
        "next": {
          "fields": {
            "slug": "/why hooks/"
          },
          "frontmatter": {
            "title": "why hooks（一）"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /All about generator/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "578f98f1747de6584495c95db534784b",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /Inside Fiber/": {
      "jsonName": "inside-fiber-8ec",
      "internalComponentName": "ComponentInsideFiber",
      "path": "/Inside Fiber/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/Inside Fiber/",
        "previous": {
          "fields": {
            "slug": "/react 16.7/"
          },
          "frontmatter": {
            "title": "react 16.7"
          }
        },
        "next": {
          "fields": {
            "slug": "/All about generator/"
          },
          "frontmatter": {
            "title": "All about generator"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /Inside Fiber/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "fa27d49d5417afb82ed6d15a5c5bde9b",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /react 16.7/": {
      "jsonName": "react-16-7-c3b",
      "internalComponentName": "ComponentReact167",
      "path": "/react 16.7/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/react 16.7/",
        "previous": {
          "fields": {
            "slug": "/react hooks@seb/"
          },
          "frontmatter": {
            "title": "react hooks@seb"
          }
        },
        "next": {
          "fields": {
            "slug": "/Inside Fiber/"
          },
          "frontmatter": {
            "title": "Inside Fiber"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /react 16.7/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "48e79961089b8ec200ce2c093e4e286d",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /react hooks@seb/": {
      "jsonName": "react-hooks-seb-80c",
      "internalComponentName": "ComponentReactHooksSeb",
      "path": "/react hooks@seb/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/react hooks@seb/",
        "previous": {
          "fields": {
            "slug": "/learning A Cartoon to Fiber/"
          },
          "frontmatter": {
            "title": "learning A Cartoon to Fiber"
          }
        },
        "next": {
          "fields": {
            "slug": "/react 16.7/"
          },
          "frontmatter": {
            "title": "react 16.7"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /react hooks@seb/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "029bb9f851b75d79cb09b9f76dbc25d7",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /learning A Cartoon to Fiber/": {
      "jsonName": "learning-a-cartoon-to-fiber-49a",
      "internalComponentName": "ComponentLearningACartoonToFiber",
      "path": "/learning A Cartoon to Fiber/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/learning A Cartoon to Fiber/",
        "previous": {
          "fields": {
            "slug": "/Promise/"
          },
          "frontmatter": {
            "title": "Promise"
          }
        },
        "next": {
          "fields": {
            "slug": "/react hooks@seb/"
          },
          "frontmatter": {
            "title": "react hooks@seb"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /learning A Cartoon to Fiber/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "d24c7bb62cd5906c2392e27b6570831c",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /Promise/": {
      "jsonName": "promise-95f",
      "internalComponentName": "ComponentPromise",
      "path": "/Promise/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/Promise/",
        "previous": {
          "fields": {
            "slug": "/state & props update/"
          },
          "frontmatter": {
            "title": "state & props update"
          }
        },
        "next": {
          "fields": {
            "slug": "/learning A Cartoon to Fiber/"
          },
          "frontmatter": {
            "title": "learning A Cartoon to Fiber"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /Promise/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "075a83575ecd12270905237eaa2fdece",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /state & props update/": {
      "jsonName": "state-props-update-e16",
      "internalComponentName": "ComponentStatePropsUpdate",
      "path": "/state & props update/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "componentChunkName": "component---src-templates-blog-post-js",
      "context": {
        "slug": "/state & props update/",
        "previous": null,
        "next": {
          "fields": {
            "slug": "/Promise/"
          },
          "frontmatter": {
            "title": "Promise"
          }
        }
      },
      "pluginCreator___NODE": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "pluginCreatorId": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js",
      "id": "SitePage /state & props update/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "a8195db38f7d40e242c1e938d8369437",
        "description": "7374ebf2-d961-52ee-92a2-c25e7cb387a9",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /404/": {
      "jsonName": "404-22d",
      "internalComponentName": "Component404",
      "path": "/404/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js",
      "componentChunkName": "component---src-pages-404-js",
      "context": {},
      "pluginCreator___NODE": "de1454a8-036b-57ef-8599-4e481f13b079",
      "pluginCreatorId": "de1454a8-036b-57ef-8599-4e481f13b079",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js",
      "id": "SitePage /404/",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "25a47886fc72adfc4261d5e3de012242",
        "description": "de1454a8-036b-57ef-8599-4e481f13b079",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /": {
      "jsonName": "index",
      "internalComponentName": "ComponentIndex",
      "path": "/",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/pages/index.js",
      "componentChunkName": "component---src-pages-index-js",
      "context": {},
      "pluginCreator___NODE": "de1454a8-036b-57ef-8599-4e481f13b079",
      "pluginCreatorId": "de1454a8-036b-57ef-8599-4e481f13b079",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/index.js",
      "id": "SitePage /",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "5081d8363c193a80af4e92cc7fcc4e1f",
        "description": "de1454a8-036b-57ef-8599-4e481f13b079",
        "owner": "internal-data-bridge"
      }
    },
    "SitePage /404.html": {
      "jsonName": "404-html-516",
      "internalComponentName": "Component404Html",
      "path": "/404.html",
      "component": "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js",
      "componentChunkName": "component---src-pages-404-js",
      "context": {},
      "pluginCreator___NODE": "f795702c-a3b8-5a88-88ee-5d06019d44fa",
      "pluginCreatorId": "f795702c-a3b8-5a88-88ee-5d06019d44fa",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js",
      "id": "SitePage /404.html",
      "parent": "SOURCE",
      "children": [],
      "internal": {
        "type": "SitePage",
        "contentDigest": "10971f3d0a22ffd200c4ed8a14c8f4d0",
        "description": "f795702c-a3b8-5a88-88ee-5d06019d44fa",
        "owner": "internal-data-bridge"
      }
    }
  },
  "status": {
    "plugins": {},
    "PLUGINS_HASH": "6ce1b85c57bc368073d99d24d22bb1fd"
  },
  "componentDataDependencies": {
    "nodes": {
      "Site": [
        "/",
        "/Inside Fiber/",
        "/react hooks@seb/",
        "/learning A Cartoon to Fiber/",
        "/Promise/",
        "/react 16.7/",
        "/why hooks/",
        "/All about generator/",
        "/state & props update/",
        "sq--src-components-seo-js"
      ],
      "55557a74-de54-5683-bd78-3de2108f3ce8": [
        "/Inside Fiber/"
      ],
      "351744df-b3d1-5265-a694-9e77f722426e": [
        "/react hooks@seb/"
      ],
      "8b5a4b64-a89e-5d42-a386-121a4aeb1e1d": [
        "/learning A Cartoon to Fiber/"
      ],
      "d16d8354-6f61-5f1a-ad48-bd02309a1329": [
        "/Promise/"
      ],
      "5d6aff10-a2ce-5c90-87e2-9613addfdbf8": [
        "/react 16.7/"
      ],
      "1b09d9a5-bd3d-5b54-a015-38a243a0175e": [
        "/why hooks/"
      ],
      "47075887-16be-50c6-96fc-5d6e79e00345": [
        "/All about generator/"
      ],
      "ea8cfa21-a625-585a-a4a0-f7228c379019": [
        "/state & props update/"
      ]
    },
    "connections": {
      "MarkdownRemark": [
        null,
        "/",
        null
      ]
    }
  },
  "jsonDataPaths": {
    "sq--src-components-seo-js": 3236765318,
    "index": "580/path---index-6a9-S7jZl2MadYxY0j2D7fy88t5qUk",
    "optimized-for-change-778": "760/path---optimized-for-change-778-742-poFtbajknC5Kk4f2Dpb6bYqTXoM",
    "my-wishlist-for-hot-reloading-5e1": "76/path---my-wishlist-for-hot-reloading-5-e-1-d05-ChKRFkmUcwIQ1bYRqzUOg3QUo",
    "how-does-setstate-know-what-to-do-c44": "590/path---how-does-setstate-know-what-to-do-c-44-cad-EFCfbQ8QgTA4SRUQw8H2iDXFzM",
    "why-do-react-elements-have-typeof-property-678": "8/path---why-do-react-elements-have-typeof-property-678-398-Ke0id29WD7WA40reZHA3mwptDw",
    "how-does-react-tell-a-class-from-a-function-45e": "148/path---how-does-react-tell-a-class-from-a-function-45-e-4b0-3ACXpnFLCMWbbfkS8Je6MLfL91Q",
    "dev-404-page-5f9": "920/path---dev-404-page-5-f-9-fab-NZuapzHg3X9TaN1iIixfv1W23E",
    "why-do-we-write-super-props-abc": "206/path---why-do-we-write-super-props-abc-42e-m0YOSACxgMMmG1vkgDhGP4RZk",
    "404-22d": "44/path---404-22-d-bce-NZuapzHg3X9TaN1iIixfv1W23E",
    "404-html-516": "164/path---404-html-516-62a-NZuapzHg3X9TaN1iIixfv1W23E",
    "inside-fiber-8ec": "632/path---inside-fiber-8-ec-531-3e1FA5nhwArJ81qk7mdiP5Hg268",
    "react-hooks-seb-80c": "712/path---react-hooks-seb-80-c-41b-6oE84fps3f0udOJEl8obZr744g",
    "promise-95f": "871/path---promise-95-f-05e-Kzvl9gxsc4cQkMot3G6qzQHU0",
    "learning-a-cartoon-to-fiber-49a": "445/path---learning-a-cartoon-to-fiber-49-a-336-0VdIaiRpcADLCLjx8M3aJvgUXU",
    "react-16-7-c3b": "602/path---react-16-7-c-3-b-58e-VvltQrVjHBwJDMBhfHYT2QdUN0",
    "all-about-generator-055": "663/path---all-about-generator-055-d4a-F4FpaAnVepMjKMqQoMS9KrAsrQ",
    "why-hooks-e09": "846/path---why-hooks-e-09-c1d-HIQM30egzEa8eIDGxJf8XUzYg",
    "state-props-update-e16": "636/path---state-props-update-e-16-282-88dz1pazmoXhHSTDNlfONO37hA"
  },
  "components": {
    "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js": {
      "query": "query BlogPostBySlug(\n  $slug: String!\n) {\n  site {\n    siteMetadata {\n      title\n      author\n    }\n  }\n  markdownRemark(fields: {slug: {eq: $slug}}) {\n    id\n    html\n    timeToRead\n    frontmatter {\n      title\n      date(formatString: \"MMMM DD, YYYY\")\n      spoiler\n    }\n    fields {\n      slug\n    }\n  }\n}\n",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/templates/blog-post.js"
    },
    "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js": {
      "query": "",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/404.js"
    },
    "/Users/xuzhanhong1/study/overreacted.io/src/pages/index.js": {
      "query": "query usersXuzhanhong1StudyOverreactedIoSrcPagesIndexJs796900122 {\n  site {\n    siteMetadata {\n      title\n      description\n    }\n  }\n  allMarkdownRemark(sort: {fields: [frontmatter___date], order: DESC}) {\n    edges {\n      node {\n        fields {\n          slug\n        }\n        timeToRead\n        frontmatter {\n          date(formatString: \"MMMM DD, YYYY\")\n          title\n          spoiler\n        }\n      }\n    }\n  }\n}\n",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/pages/index.js"
    }
  },
  "staticQueryComponents": {
    "sq--src-components-seo-js": {
      "name": "GetSiteMetadata",
      "componentPath": "/Users/xuzhanhong1/study/overreacted.io/src/components/SEO.js",
      "id": "sq--src-components-seo-js",
      "jsonName": "sq--src-components-seo-js",
      "query": "query GetSiteMetadata {\n  site {\n    siteMetadata {\n      title\n      author\n      description\n      siteUrl\n      social {\n        twitter\n      }\n    }\n  }\n}\n",
      "hash": 3236765318
    }
  }
}